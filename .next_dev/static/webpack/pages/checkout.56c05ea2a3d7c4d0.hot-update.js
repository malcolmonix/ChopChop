"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/checkout",{

/***/ "./lib/firebase/orders.ts":
/*!********************************!*\
  !*** ./lib/firebase/orders.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrderService: function() { return /* binding */ OrderService; }\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client */ \"./lib/firebase/client.ts\");\n\n\n// // import { OrderSyncService } from './order-sync'; // Temporarily disabled to fix build // Temporarily disabled to fix build\n// Initialize Firestore\nconst db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getFirestore)((0,_client__WEBPACK_IMPORTED_MODULE_1__.getFirebaseApp)());\nclass OrderService {\n    static async placeOrder(param) {\n        let { restaurant, restaurantName, orderInput, paymentMethod, address, customer, deliveryCharges = 0, tipping = 0, taxationAmount = 0, instructions = \"\", isPickedUp = false, userId } = param;\n        try {\n            // Calculate order details\n            const subtotal = orderInput.reduce((sum, item)=>sum + item.price * item.quantity, 0);\n            const orderAmount = subtotal + deliveryCharges + tipping + taxationAmount;\n            // Determine order status based on payment method\n            let orderStatus = \"PENDING\";\n            let paidAmount = 0;\n            if (paymentMethod === \"CASH\") {\n                orderStatus = \"PENDING\"; // Will be paid on delivery\n                paidAmount = 0;\n            } else if (paymentMethod === \"CARD\" || paymentMethod === \"WALLET\") {\n                orderStatus = \"CONFIRMED\"; // Electronic payments - assume paid immediately\n                paidAmount = orderAmount;\n            } else if (paymentMethod === \"BANK\") {\n                orderStatus = \"PAYMENT_PENDING\"; // Bank transfer - awaiting verification\n                paidAmount = 0;\n            }\n            const orderCode = \"CC\".concat(Date.now());\n            // Create Firebase order object (removing undefined values)\n            const firestoreOrder = {\n                orderId: orderCode,\n                restaurantId: restaurant,\n                orderStatus,\n                paymentMethod,\n                orderAmount,\n                paidAmount,\n                deliveryCharges,\n                tipping,\n                taxationAmount,\n                orderDate: new Date().toISOString(),\n                isPickedUp,\n                createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                items: orderInput,\n                // Vendor notification fields for MenuVerse integration\n                vendorNotified: false,\n                orderType: \"delivery\",\n                platform: \"ChopChop\"\n            };\n            // Only add optional fields if they have values\n            if (address === null || address === void 0 ? void 0 : address.deliveryAddress) {\n                firestoreOrder.deliveryAddress = address.deliveryAddress;\n            }\n            if ((address === null || address === void 0 ? void 0 : address.latitude) !== undefined) {\n                firestoreOrder.deliveryLatitude = address.latitude;\n            }\n            if ((address === null || address === void 0 ? void 0 : address.longitude) !== undefined) {\n                firestoreOrder.deliveryLongitude = address.longitude;\n            }\n            if (instructions) {\n                firestoreOrder.instructions = instructions;\n            }\n            // Save to Firebase orders collection\n            const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"orders\"), firestoreOrder);\n            console.log(\"‚úÖ Order \".concat(orderCode, \" saved to Firebase with ID:\"), docRef.id);\n            // ALSO save to vendor-specific collection for MenuVerse notifications\n            console.log(\"\\uD83D\\uDE80 STARTING vendor save process for order \".concat(orderCode, \"...\"));\n            try {\n                // Dynamic restaurant-to-vendor mapping\n                // In production, this would come from a database lookup\n                // For now, we'll try to find the vendor UID dynamically\n                console.log(\"\\uD83D\\uDD0D Looking up vendor for restaurant ID: \".concat(restaurant));\n                // Method 1: Try to find vendor by querying the eateries collection\n                let vendorUID = null;\n                try {\n                    // Query the eateries collection to find which vendor owns this restaurant\n                    const eateriesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"eateries\"));\n                    for (const doc of eateriesSnapshot.docs){\n                        const eateryData = doc.data();\n                        // Check if this eatery has this restaurant ID\n                        // This assumes the eatery document has a restaurantIds array or similar\n                        if (eateryData.restaurantIds && eateryData.restaurantIds.includes(restaurant)) {\n                            vendorUID = doc.id;\n                            console.log(\"‚úÖ Found vendor \".concat(vendorUID, \" for restaurant \").concat(restaurant));\n                            break;\n                        }\n                        // Alternative: check if restaurant ID matches the eatery ID\n                        if (eateryData.id === restaurant || eateryData.restaurantId === restaurant) {\n                            vendorUID = doc.id;\n                            console.log(\"‚úÖ Found vendor \".concat(vendorUID, \" for restaurant \").concat(restaurant, \" (direct match)\"));\n                            break;\n                        }\n                    }\n                } catch (lookupError) {\n                    console.warn(\"‚ö†Ô∏è Could not lookup vendor from eateries collection:\", lookupError);\n                }\n                // Method 2: If no specific mapping found, save to all active vendors\n                // This ensures orders don't get lost while the mapping system is being set up\n                const vendorUIDs = [];\n                if (vendorUID) {\n                    vendorUIDs.push(vendorUID);\n                } else {\n                    console.log(\"\\uD83D\\uDD04 No specific vendor found for restaurant \".concat(restaurant, \", will save to all active vendors\"));\n                    // Get all vendor UIDs from eateries collection\n                    try {\n                        const allEateriesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"eateries\"));\n                        if (allEateriesSnapshot.docs.length > 0) {\n                            const allVendorUIDs = allEateriesSnapshot.docs.map((doc)=>doc.id);\n                            vendorUIDs.push(...allVendorUIDs);\n                            console.log(\"\\uD83D\\uDCCB Found \".concat(allVendorUIDs.length, \" active vendors:\"), allVendorUIDs);\n                        } else {\n                            console.log(\"\\uD83D\\uDCED No eateries collection found. Creating vendor entry for current demo user.\");\n                            // If no eateries exist, create one for the demo vendor\n                            vendorUIDs.push(\"0GI3MojVnLfvzSEqMc25oCzAmCz2\");\n                        }\n                    } catch (allVendorsError) {\n                        console.warn(\"‚ö†Ô∏è Could not get all vendors, using fallback UIDs\");\n                        // Fallback to known UIDs if the query fails\n                        vendorUIDs.push(\"0GI3MojVnLfvzSEqMc25oCzAmCz2\"); // Current demo vendor\n                    }\n                }\n                console.log(\"\\uD83C\\uDFAF Will save order to \".concat(vendorUIDs.length, \" vendor(s):\"), vendorUIDs);\n                // Save order to each vendor's collection\n                for (const currentVendorUID of vendorUIDs){\n                    try {\n                        // First, ensure the vendor's eatery document exists\n                        const eateryDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(db, \"eateries\", currentVendorUID);\n                        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)(eateryDocRef, {\n                            id: currentVendorUID,\n                            name: restaurantName || \"Restaurant\",\n                            email: \"vendor@chopchop.com\",\n                            createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                            restaurantIds: [\n                                restaurant\n                            ] // Map this vendor to this restaurant\n                        }, {\n                            merge: true\n                        }); // merge: true means only update if document doesn't exist\n                        console.log(\"‚úÖ Ensured eatery document exists for vendor: \".concat(currentVendorUID));\n                        const vendorOrderData = {\n                            // Use the exact same structure that MenuVerse expects\n                            id: docRef.id,\n                            eateryId: currentVendorUID,\n                            customer: {\n                                name: (customer === null || customer === void 0 ? void 0 : customer.name) || \"ChopChop Customer\",\n                                email: (customer === null || customer === void 0 ? void 0 : customer.email) || \"customer@chopchop.com\",\n                                address: (address === null || address === void 0 ? void 0 : address.deliveryAddress) || (customer === null || customer === void 0 ? void 0 : customer.address) || \"No address provided\"\n                            },\n                            items: orderInput.map((item, index)=>({\n                                    id: \"\".concat(docRef.id, \"-item-\").concat(index),\n                                    name: item.title,\n                                    quantity: item.quantity,\n                                    price: item.price\n                                })),\n                            totalAmount: orderAmount,\n                            status: orderStatus === \"PENDING\" ? \"Pending\" : orderStatus === \"CONFIRMED\" ? \"Confirmed\" : \"Pending\",\n                            createdAt: firestoreOrder.createdAt,\n                            // Additional ChopChop specific fields\n                            orderId: orderCode,\n                            restaurantId: restaurant,\n                            paymentMethod,\n                            platform: \"ChopChop\"\n                        };\n                        const vendorPath = \"eateries/\".concat(currentVendorUID, \"/orders\");\n                        const vendorDocRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"eateries\", currentVendorUID, \"orders\"), vendorOrderData);\n                        console.log(\"‚úÖ Order \".concat(orderCode, \" saved to vendor path: \").concat(vendorPath, \" with ID: \").concat(vendorDocRef.id));\n                        console.log(\"\\uD83D\\uDCCA Order data saved:\", vendorOrderData);\n                        console.log(\"\\uD83C\\uDFAF VERIFICATION: Order should be visible at Firebase path: eateries/\".concat(currentVendorUID, \"/orders/\").concat(vendorDocRef.id));\n                        // üîÑ SYNC TO CUSTOMER ORDERS: Save order to customer-accessible collection\n                        try {\n                            // Inline customer order sync\n                            const customerOrderData = {\n                                orderId: orderCode,\n                                customerId: userId || (customer === null || customer === void 0 ? void 0 : customer.email) || \"customer-\".concat(Date.now()),\n                                vendorId: currentVendorUID,\n                                restaurantId: restaurant,\n                                restaurantName: restaurantName || \"Restaurant\",\n                                customer: {\n                                    name: (customer === null || customer === void 0 ? void 0 : customer.name) || \"ChopChop Customer\",\n                                    email: (customer === null || customer === void 0 ? void 0 : customer.email) || \"customer@chopchop.com\",\n                                    address: (address === null || address === void 0 ? void 0 : address.deliveryAddress) || (customer === null || customer === void 0 ? void 0 : customer.address) || \"No address provided\"\n                                },\n                                items: orderInput.map((item, index)=>({\n                                        id: \"\".concat(orderCode, \"-item-\").concat(index),\n                                        name: item.title,\n                                        quantity: item.quantity,\n                                        price: item.price\n                                    })),\n                                totalAmount: orderAmount,\n                                status: orderStatus === \"PENDING\" ? \"Pending\" : orderStatus === \"CONFIRMED\" ? \"Confirmed\" : \"Pending\",\n                                paymentMethod: paymentMethod,\n                                createdAt: firestoreOrder.createdAt,\n                                updatedAt: firestoreOrder.createdAt,\n                                trackingUpdates: [\n                                    {\n                                        status: orderStatus === \"PENDING\" ? \"Pending\" : orderStatus === \"CONFIRMED\" ? \"Confirmed\" : \"Pending\",\n                                        timestamp: firestoreOrder.createdAt,\n                                        message: \"Order \".concat(orderStatus === \"PENDING\" ? \"pending\" : orderStatus === \"CONFIRMED\" ? \"confirmed\" : \"pending\", \" by restaurant\"),\n                                        location: restaurantName || \"Restaurant\"\n                                    }\n                                ]\n                            };\n                            const customerOrderRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"customer-orders\"), customerOrderData);\n                            console.log(\"‚úÖ Customer order synced: customer-orders/\".concat(customerOrderRef.id));\n                        } catch (syncError) {\n                            console.warn(\"‚ö†Ô∏è Failed to sync customer order:\", syncError);\n                        // Don't fail the main order - this is supplementary\n                        }\n                    } catch (pathError) {\n                        console.error(\"‚ùå Failed to save to vendor UID \".concat(currentVendorUID, \":\"), pathError);\n                    }\n                }\n                // IMPORTANT: Let's also try to save to a predictable path for testing\n                // This will help us debug what's happening\n                try {\n                    const debugOrderData = {\n                        id: docRef.id,\n                        eateryId: \"DEBUG_VENDOR\",\n                        customer: {\n                            name: \"Debug Customer\",\n                            email: \"debug@test.com\",\n                            address: \"Debug Address\"\n                        },\n                        items: [\n                            {\n                                id: \"debug-item\",\n                                name: \"Debug Item\",\n                                quantity: 1,\n                                price: 10.99\n                            }\n                        ],\n                        totalAmount: 10.99,\n                        status: \"Pending\",\n                        createdAt: firestoreOrder.createdAt,\n                        debugInfo: {\n                            originalRestaurantId: restaurant,\n                            orderCode: orderCode,\n                            timestamp: new Date().toISOString(),\n                            source: \"ChopChop Debug Save\"\n                        }\n                    };\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"eateries\", \"DEBUG_VENDOR\", \"orders\"), debugOrderData);\n                    console.log(\"\\uD83D\\uDC1B DEBUG: Order saved to eateries/DEBUG_VENDOR/orders for testing\");\n                } catch (debugError) {\n                    console.warn(\"Debug save failed:\", debugError);\n                }\n            } catch (vendorError) {\n                console.error(\"‚ö†Ô∏è Failed to save to vendor collections:\", vendorError);\n            // Don't throw - global order was saved successfully\n            }\n            return {\n                orderId: orderCode,\n                orderStatus,\n                total: orderAmount,\n                firebaseId: docRef.id\n            };\n        } catch (error) {\n            console.error(\"‚ùå Firebase order creation failed:\", error);\n            throw new Error(\"Failed to place order: \".concat(error.message));\n        }\n    }\n    static async updateOrderStatus(firebaseId, status, paidAmount) {\n        try {\n            const { updateDoc, doc } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! firebase/firestore */ \"./node_modules/firebase/firestore/dist/esm/index.esm.js\"));\n            const orderRef = doc(db, \"orders\", firebaseId);\n            const updateData = {\n                orderStatus: status,\n                updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n            };\n            if (paidAmount !== undefined) {\n                updateData.paidAmount = paidAmount;\n            }\n            await updateDoc(orderRef, updateData);\n            console.log(\"‚úÖ Order \".concat(firebaseId, \" status updated to \").concat(status));\n        } catch (error) {\n            console.error(\"‚ùå Firebase order update failed:\", error);\n            throw error;\n        }\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (OrderService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QXFDQTtZQUNuRCxNQUFNLElBQUlTLE1BQU0sMEJBQXdDLE9BQWRULE1BQU1MLE9BQU87UUFDekQ7SUFDRjtJQUVBLGFBQWFlLGtCQUFrQkYsVUFBa0IsRUFBRXRCLE1BQWMsRUFBRWxELFVBQW1CLEVBQUU7UUFDdEYsSUFBSTtZQUNGLE1BQU0sRUFBRTJFLFNBQVMsRUFBRXJHLEdBQUcsRUFBRSxHQUFHLE1BQU0seUtBQU87WUFDeEMsTUFBTXNHLFdBQVd0RyxJQUFJRyxJQUFJLFVBQVUrRjtZQUVuQyxNQUFNSyxhQUFrQjtnQkFDdEI5RSxhQUFhbUQ7Z0JBQ2JNLFdBQVdwRixtRUFBZUE7WUFDNUI7WUFFQSxJQUFJNEIsZUFBZWdCLFdBQVc7Z0JBQzVCNkQsV0FBVzdFLFVBQVUsR0FBR0E7WUFDMUI7WUFFQSxNQUFNMkUsVUFBVUMsVUFBVUM7WUFDMUJ4RCxRQUFRQyxHQUFHLENBQUMsV0FBMkM0QixPQUFoQ3NCLFlBQVcsdUJBQTRCLE9BQVB0QjtRQUV6RCxFQUFFLE9BQU9jLE9BQU87WUFDZDNDLFFBQVEyQyxLQUFLLENBQUMsbUNBQW1DQTtZQUNqRCxNQUFNQTtRQUNSO0lBQ0Y7QUFDRjtBQUVBLCtEQUFldEYsWUFBWUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvZmlyZWJhc2Uvb3JkZXJzLnRzPzA5NGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0RmlyZXN0b3JlLCBjb2xsZWN0aW9uLCBhZGREb2MsIHNlcnZlclRpbWVzdGFtcCwgZ2V0RG9jcywgZG9jLCBzZXREb2MgfSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xyXG5pbXBvcnQgeyBnZXRGaXJlYmFzZUFwcCB9IGZyb20gJy4vY2xpZW50JztcclxuLy8gLy8gaW1wb3J0IHsgT3JkZXJTeW5jU2VydmljZSB9IGZyb20gJy4vb3JkZXItc3luYyc7IC8vIFRlbXBvcmFyaWx5IGRpc2FibGVkIHRvIGZpeCBidWlsZCAvLyBUZW1wb3JhcmlseSBkaXNhYmxlZCB0byBmaXggYnVpbGRcclxuXHJcbi8vIEluaXRpYWxpemUgRmlyZXN0b3JlXHJcbmNvbnN0IGRiID0gZ2V0RmlyZXN0b3JlKGdldEZpcmViYXNlQXBwKCkpO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPcmRlckl0ZW0ge1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgcXVhbnRpdHk6IG51bWJlcjtcclxuICBwcmljZTogbnVtYmVyO1xyXG4gIHZhcmlhdGlvbj86IHN0cmluZztcclxuICBhZGRvbnM/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgT3JkZXJBZGRyZXNzIHtcclxuICBkZWxpdmVyeUFkZHJlc3M6IHN0cmluZztcclxuICBsYXRpdHVkZT86IG51bWJlcjtcclxuICBsb25naXR1ZGU/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRmlyZWJhc2VPcmRlciB7XHJcbiAgb3JkZXJJZDogc3RyaW5nO1xyXG4gIHJlc3RhdXJhbnRJZDogbnVtYmVyO1xyXG4gIG9yZGVyU3RhdHVzOiBzdHJpbmc7XHJcbiAgcGF5bWVudE1ldGhvZDogc3RyaW5nO1xyXG4gIG9yZGVyQW1vdW50OiBudW1iZXI7XHJcbiAgcGFpZEFtb3VudDogbnVtYmVyO1xyXG4gIGRlbGl2ZXJ5QWRkcmVzcz86IHN0cmluZztcclxuICBkZWxpdmVyeUxhdGl0dWRlPzogbnVtYmVyO1xyXG4gIGRlbGl2ZXJ5TG9uZ2l0dWRlPzogbnVtYmVyO1xyXG4gIGluc3RydWN0aW9ucz86IHN0cmluZztcclxuICBkZWxpdmVyeUNoYXJnZXM6IG51bWJlcjtcclxuICB0aXBwaW5nOiBudW1iZXI7XHJcbiAgdGF4YXRpb25BbW91bnQ6IG51bWJlcjtcclxuICBvcmRlckRhdGU6IHN0cmluZztcclxuICBpc1BpY2tlZFVwOiBib29sZWFuO1xyXG4gIGNyZWF0ZWRBdDogYW55OyAvLyBzZXJ2ZXJUaW1lc3RhbXBcclxuICBpdGVtczogT3JkZXJJdGVtW107XHJcbiAgdmVuZG9yTm90aWZpZWQ6IGJvb2xlYW47XHJcbiAgb3JkZXJUeXBlOiBzdHJpbmc7XHJcbiAgcGxhdGZvcm06IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE9yZGVyU2VydmljZSB7XHJcbiAgc3RhdGljIGFzeW5jIHBsYWNlT3JkZXIoe1xyXG4gICAgcmVzdGF1cmFudCxcclxuICAgIHJlc3RhdXJhbnROYW1lLFxyXG4gICAgb3JkZXJJbnB1dCxcclxuICAgIHBheW1lbnRNZXRob2QsXHJcbiAgICBhZGRyZXNzLFxyXG4gICAgY3VzdG9tZXIsXHJcbiAgICBkZWxpdmVyeUNoYXJnZXMgPSAwLFxyXG4gICAgdGlwcGluZyA9IDAsXHJcbiAgICB0YXhhdGlvbkFtb3VudCA9IDAsXHJcbiAgICBpbnN0cnVjdGlvbnMgPSAnJyxcclxuICAgIGlzUGlja2VkVXAgPSBmYWxzZSxcclxuICAgIHVzZXJJZFxyXG4gIH06IHtcclxuICAgIHJlc3RhdXJhbnQ6IG51bWJlcjtcclxuICAgIHJlc3RhdXJhbnROYW1lPzogc3RyaW5nO1xyXG4gICAgb3JkZXJJbnB1dDogT3JkZXJJdGVtW107XHJcbiAgICBwYXltZW50TWV0aG9kOiBzdHJpbmc7XHJcbiAgICBhZGRyZXNzPzogT3JkZXJBZGRyZXNzO1xyXG4gICAgY3VzdG9tZXI/OiB7XHJcbiAgICAgIG5hbWU6IHN0cmluZztcclxuICAgICAgZW1haWw6IHN0cmluZztcclxuICAgICAgYWRkcmVzcz86IHN0cmluZztcclxuICAgIH07XHJcbiAgICBkZWxpdmVyeUNoYXJnZXM/OiBudW1iZXI7XHJcbiAgICB0aXBwaW5nPzogbnVtYmVyO1xyXG4gICAgdGF4YXRpb25BbW91bnQ/OiBudW1iZXI7XHJcbiAgICBpbnN0cnVjdGlvbnM/OiBzdHJpbmc7XHJcbiAgICBpc1BpY2tlZFVwPzogYm9vbGVhbjtcclxuICAgIHVzZXJJZD86IHN0cmluZztcclxuICB9KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBDYWxjdWxhdGUgb3JkZXIgZGV0YWlsc1xyXG4gICAgICBjb25zdCBzdWJ0b3RhbCA9IG9yZGVySW5wdXQucmVkdWNlKChzdW0sIGl0ZW0pID0+IHN1bSArIChpdGVtLnByaWNlICogaXRlbS5xdWFudGl0eSksIDApO1xyXG4gICAgICBjb25zdCBvcmRlckFtb3VudCA9IHN1YnRvdGFsICsgZGVsaXZlcnlDaGFyZ2VzICsgdGlwcGluZyArIHRheGF0aW9uQW1vdW50O1xyXG4gICAgICBcclxuICAgICAgLy8gRGV0ZXJtaW5lIG9yZGVyIHN0YXR1cyBiYXNlZCBvbiBwYXltZW50IG1ldGhvZFxyXG4gICAgICBsZXQgb3JkZXJTdGF0dXMgPSAnUEVORElORyc7XHJcbiAgICAgIGxldCBwYWlkQW1vdW50ID0gMDtcclxuICAgICAgXHJcbiAgICAgIGlmIChwYXltZW50TWV0aG9kID09PSAnQ0FTSCcpIHtcclxuICAgICAgICBvcmRlclN0YXR1cyA9ICdQRU5ESU5HJzsgLy8gV2lsbCBiZSBwYWlkIG9uIGRlbGl2ZXJ5XHJcbiAgICAgICAgcGFpZEFtb3VudCA9IDA7XHJcbiAgICAgIH0gZWxzZSBpZiAocGF5bWVudE1ldGhvZCA9PT0gJ0NBUkQnIHx8IHBheW1lbnRNZXRob2QgPT09ICdXQUxMRVQnKSB7XHJcbiAgICAgICAgb3JkZXJTdGF0dXMgPSAnQ09ORklSTUVEJzsgLy8gRWxlY3Ryb25pYyBwYXltZW50cyAtIGFzc3VtZSBwYWlkIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgcGFpZEFtb3VudCA9IG9yZGVyQW1vdW50O1xyXG4gICAgICB9IGVsc2UgaWYgKHBheW1lbnRNZXRob2QgPT09ICdCQU5LJykge1xyXG4gICAgICAgIG9yZGVyU3RhdHVzID0gJ1BBWU1FTlRfUEVORElORyc7IC8vIEJhbmsgdHJhbnNmZXIgLSBhd2FpdGluZyB2ZXJpZmljYXRpb25cclxuICAgICAgICBwYWlkQW1vdW50ID0gMDtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3Qgb3JkZXJDb2RlID0gYENDJHtEYXRlLm5vdygpfWA7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDcmVhdGUgRmlyZWJhc2Ugb3JkZXIgb2JqZWN0IChyZW1vdmluZyB1bmRlZmluZWQgdmFsdWVzKVxyXG4gICAgICBjb25zdCBmaXJlc3RvcmVPcmRlcjogYW55ID0ge1xyXG4gICAgICAgIG9yZGVySWQ6IG9yZGVyQ29kZSxcclxuICAgICAgICByZXN0YXVyYW50SWQ6IHJlc3RhdXJhbnQsXHJcbiAgICAgICAgb3JkZXJTdGF0dXMsXHJcbiAgICAgICAgcGF5bWVudE1ldGhvZCxcclxuICAgICAgICBvcmRlckFtb3VudCxcclxuICAgICAgICBwYWlkQW1vdW50LFxyXG4gICAgICAgIGRlbGl2ZXJ5Q2hhcmdlcyxcclxuICAgICAgICB0aXBwaW5nLFxyXG4gICAgICAgIHRheGF0aW9uQW1vdW50LFxyXG4gICAgICAgIG9yZGVyRGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIGlzUGlja2VkVXAsXHJcbiAgICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcclxuICAgICAgICBpdGVtczogb3JkZXJJbnB1dCxcclxuICAgICAgICAvLyBWZW5kb3Igbm90aWZpY2F0aW9uIGZpZWxkcyBmb3IgTWVudVZlcnNlIGludGVncmF0aW9uXHJcbiAgICAgICAgdmVuZG9yTm90aWZpZWQ6IGZhbHNlLFxyXG4gICAgICAgIG9yZGVyVHlwZTogJ2RlbGl2ZXJ5JyxcclxuICAgICAgICBwbGF0Zm9ybTogJ0Nob3BDaG9wJ1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gT25seSBhZGQgb3B0aW9uYWwgZmllbGRzIGlmIHRoZXkgaGF2ZSB2YWx1ZXNcclxuICAgICAgaWYgKGFkZHJlc3M/LmRlbGl2ZXJ5QWRkcmVzcykge1xyXG4gICAgICAgIGZpcmVzdG9yZU9yZGVyLmRlbGl2ZXJ5QWRkcmVzcyA9IGFkZHJlc3MuZGVsaXZlcnlBZGRyZXNzO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhZGRyZXNzPy5sYXRpdHVkZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZmlyZXN0b3JlT3JkZXIuZGVsaXZlcnlMYXRpdHVkZSA9IGFkZHJlc3MubGF0aXR1ZGU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGFkZHJlc3M/LmxvbmdpdHVkZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZmlyZXN0b3JlT3JkZXIuZGVsaXZlcnlMb25naXR1ZGUgPSBhZGRyZXNzLmxvbmdpdHVkZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaW5zdHJ1Y3Rpb25zKSB7XHJcbiAgICAgICAgZmlyZXN0b3JlT3JkZXIuaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBTYXZlIHRvIEZpcmViYXNlIG9yZGVycyBjb2xsZWN0aW9uXHJcbiAgICAgIGNvbnN0IGRvY1JlZiA9IGF3YWl0IGFkZERvYyhjb2xsZWN0aW9uKGRiLCAnb3JkZXJzJyksIGZpcmVzdG9yZU9yZGVyKTtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBPcmRlciAke29yZGVyQ29kZX0gc2F2ZWQgdG8gRmlyZWJhc2Ugd2l0aCBJRDpgLCBkb2NSZWYuaWQpO1xyXG5cclxuICAgICAgLy8gQUxTTyBzYXZlIHRvIHZlbmRvci1zcGVjaWZpYyBjb2xsZWN0aW9uIGZvciBNZW51VmVyc2Ugbm90aWZpY2F0aW9uc1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+agCBTVEFSVElORyB2ZW5kb3Igc2F2ZSBwcm9jZXNzIGZvciBvcmRlciAke29yZGVyQ29kZX0uLi5gKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBEeW5hbWljIHJlc3RhdXJhbnQtdG8tdmVuZG9yIG1hcHBpbmdcclxuICAgICAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGNvbWUgZnJvbSBhIGRhdGFiYXNlIGxvb2t1cFxyXG4gICAgICAgIC8vIEZvciBub3csIHdlJ2xsIHRyeSB0byBmaW5kIHRoZSB2ZW5kb3IgVUlEIGR5bmFtaWNhbGx5XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coYPCflI0gTG9va2luZyB1cCB2ZW5kb3IgZm9yIHJlc3RhdXJhbnQgSUQ6ICR7cmVzdGF1cmFudH1gKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBNZXRob2QgMTogVHJ5IHRvIGZpbmQgdmVuZG9yIGJ5IHF1ZXJ5aW5nIHRoZSBlYXRlcmllcyBjb2xsZWN0aW9uXHJcbiAgICAgICAgbGV0IHZlbmRvclVJRDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIFF1ZXJ5IHRoZSBlYXRlcmllcyBjb2xsZWN0aW9uIHRvIGZpbmQgd2hpY2ggdmVuZG9yIG93bnMgdGhpcyByZXN0YXVyYW50XHJcbiAgICAgICAgICBjb25zdCBlYXRlcmllc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhjb2xsZWN0aW9uKGRiLCAnZWF0ZXJpZXMnKSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGZvciAoY29uc3QgZG9jIG9mIGVhdGVyaWVzU25hcHNob3QuZG9jcykge1xyXG4gICAgICAgICAgICBjb25zdCBlYXRlcnlEYXRhID0gZG9jLmRhdGEoKTtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBlYXRlcnkgaGFzIHRoaXMgcmVzdGF1cmFudCBJRFxyXG4gICAgICAgICAgICAvLyBUaGlzIGFzc3VtZXMgdGhlIGVhdGVyeSBkb2N1bWVudCBoYXMgYSByZXN0YXVyYW50SWRzIGFycmF5IG9yIHNpbWlsYXJcclxuICAgICAgICAgICAgaWYgKGVhdGVyeURhdGEucmVzdGF1cmFudElkcyAmJiBlYXRlcnlEYXRhLnJlc3RhdXJhbnRJZHMuaW5jbHVkZXMocmVzdGF1cmFudCkpIHtcclxuICAgICAgICAgICAgICB2ZW5kb3JVSUQgPSBkb2MuaWQ7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCB2ZW5kb3IgJHt2ZW5kb3JVSUR9IGZvciByZXN0YXVyYW50ICR7cmVzdGF1cmFudH1gKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBbHRlcm5hdGl2ZTogY2hlY2sgaWYgcmVzdGF1cmFudCBJRCBtYXRjaGVzIHRoZSBlYXRlcnkgSURcclxuICAgICAgICAgICAgaWYgKGVhdGVyeURhdGEuaWQgPT09IHJlc3RhdXJhbnQgfHwgZWF0ZXJ5RGF0YS5yZXN0YXVyYW50SWQgPT09IHJlc3RhdXJhbnQpIHtcclxuICAgICAgICAgICAgICB2ZW5kb3JVSUQgPSBkb2MuaWQ7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCB2ZW5kb3IgJHt2ZW5kb3JVSUR9IGZvciByZXN0YXVyYW50ICR7cmVzdGF1cmFudH0gKGRpcmVjdCBtYXRjaClgKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGxvb2t1cEVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBDb3VsZCBub3QgbG9va3VwIHZlbmRvciBmcm9tIGVhdGVyaWVzIGNvbGxlY3Rpb246JywgbG9va3VwRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBNZXRob2QgMjogSWYgbm8gc3BlY2lmaWMgbWFwcGluZyBmb3VuZCwgc2F2ZSB0byBhbGwgYWN0aXZlIHZlbmRvcnNcclxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgb3JkZXJzIGRvbid0IGdldCBsb3N0IHdoaWxlIHRoZSBtYXBwaW5nIHN5c3RlbSBpcyBiZWluZyBzZXQgdXBcclxuICAgICAgICBjb25zdCB2ZW5kb3JVSURzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh2ZW5kb3JVSUQpIHtcclxuICAgICAgICAgIHZlbmRvclVJRHMucHVzaCh2ZW5kb3JVSUQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UhCBObyBzcGVjaWZpYyB2ZW5kb3IgZm91bmQgZm9yIHJlc3RhdXJhbnQgJHtyZXN0YXVyYW50fSwgd2lsbCBzYXZlIHRvIGFsbCBhY3RpdmUgdmVuZG9yc2ApO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBHZXQgYWxsIHZlbmRvciBVSURzIGZyb20gZWF0ZXJpZXMgY29sbGVjdGlvblxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgYWxsRWF0ZXJpZXNTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MoY29sbGVjdGlvbihkYiwgJ2VhdGVyaWVzJykpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGFsbEVhdGVyaWVzU25hcHNob3QuZG9jcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgYWxsVmVuZG9yVUlEcyA9IGFsbEVhdGVyaWVzU25hcHNob3QuZG9jcy5tYXAoZG9jID0+IGRvYy5pZCk7XHJcbiAgICAgICAgICAgICAgdmVuZG9yVUlEcy5wdXNoKC4uLmFsbFZlbmRvclVJRHMpO1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OLIEZvdW5kICR7YWxsVmVuZG9yVUlEcy5sZW5ndGh9IGFjdGl2ZSB2ZW5kb3JzOmAsIGFsbFZlbmRvclVJRHMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OtIE5vIGVhdGVyaWVzIGNvbGxlY3Rpb24gZm91bmQuIENyZWF0aW5nIHZlbmRvciBlbnRyeSBmb3IgY3VycmVudCBkZW1vIHVzZXIuYCk7XHJcbiAgICAgICAgICAgICAgLy8gSWYgbm8gZWF0ZXJpZXMgZXhpc3QsIGNyZWF0ZSBvbmUgZm9yIHRoZSBkZW1vIHZlbmRvclxyXG4gICAgICAgICAgICAgIHZlbmRvclVJRHMucHVzaCgnMEdJM01valZuTGZ2elNFcU1jMjVvQ3pBbUN6MicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChhbGxWZW5kb3JzRXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gQ291bGQgbm90IGdldCBhbGwgdmVuZG9ycywgdXNpbmcgZmFsbGJhY2sgVUlEcycpO1xyXG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBrbm93biBVSURzIGlmIHRoZSBxdWVyeSBmYWlsc1xyXG4gICAgICAgICAgICB2ZW5kb3JVSURzLnB1c2goJzBHSTNNb2pWbkxmdnpTRXFNYzI1b0N6QW1DejInKTsgLy8gQ3VycmVudCBkZW1vIHZlbmRvclxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYPCfjq8gV2lsbCBzYXZlIG9yZGVyIHRvICR7dmVuZG9yVUlEcy5sZW5ndGh9IHZlbmRvcihzKTpgLCB2ZW5kb3JVSURzKTtcclxuXHJcbiAgICAgICAgLy8gU2F2ZSBvcmRlciB0byBlYWNoIHZlbmRvcidzIGNvbGxlY3Rpb25cclxuICAgICAgICBmb3IgKGNvbnN0IGN1cnJlbnRWZW5kb3JVSUQgb2YgdmVuZG9yVUlEcykge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gRmlyc3QsIGVuc3VyZSB0aGUgdmVuZG9yJ3MgZWF0ZXJ5IGRvY3VtZW50IGV4aXN0c1xyXG4gICAgICAgICAgICBjb25zdCBlYXRlcnlEb2NSZWYgPSBkb2MoZGIsICdlYXRlcmllcycsIGN1cnJlbnRWZW5kb3JVSUQpO1xyXG4gICAgICAgICAgICBhd2FpdCBzZXREb2MoZWF0ZXJ5RG9jUmVmLCB7XHJcbiAgICAgICAgICAgICAgaWQ6IGN1cnJlbnRWZW5kb3JVSUQsXHJcbiAgICAgICAgICAgICAgbmFtZTogcmVzdGF1cmFudE5hbWUgfHwgJ1Jlc3RhdXJhbnQnLCAvLyBVc2UgYWN0dWFsIHJlc3RhdXJhbnQgbmFtZVxyXG4gICAgICAgICAgICAgIGVtYWlsOiAndmVuZG9yQGNob3BjaG9wLmNvbScsXHJcbiAgICAgICAgICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcclxuICAgICAgICAgICAgICByZXN0YXVyYW50SWRzOiBbcmVzdGF1cmFudF0gLy8gTWFwIHRoaXMgdmVuZG9yIHRvIHRoaXMgcmVzdGF1cmFudFxyXG4gICAgICAgICAgICB9LCB7IG1lcmdlOiB0cnVlIH0pOyAvLyBtZXJnZTogdHJ1ZSBtZWFucyBvbmx5IHVwZGF0ZSBpZiBkb2N1bWVudCBkb2Vzbid0IGV4aXN0XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEVuc3VyZWQgZWF0ZXJ5IGRvY3VtZW50IGV4aXN0cyBmb3IgdmVuZG9yOiAke2N1cnJlbnRWZW5kb3JVSUR9YCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCB2ZW5kb3JPcmRlckRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgLy8gVXNlIHRoZSBleGFjdCBzYW1lIHN0cnVjdHVyZSB0aGF0IE1lbnVWZXJzZSBleHBlY3RzXHJcbiAgICAgICAgICAgICAgaWQ6IGRvY1JlZi5pZCxcclxuICAgICAgICAgICAgICBlYXRlcnlJZDogY3VycmVudFZlbmRvclVJRCxcclxuICAgICAgICAgICAgICBjdXN0b21lcjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogY3VzdG9tZXI/Lm5hbWUgfHwgJ0Nob3BDaG9wIEN1c3RvbWVyJyxcclxuICAgICAgICAgICAgICAgIGVtYWlsOiBjdXN0b21lcj8uZW1haWwgfHwgJ2N1c3RvbWVyQGNob3BjaG9wLmNvbScsXHJcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzPy5kZWxpdmVyeUFkZHJlc3MgfHwgY3VzdG9tZXI/LmFkZHJlc3MgfHwgJ05vIGFkZHJlc3MgcHJvdmlkZWQnXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBpdGVtczogb3JkZXJJbnB1dC5tYXAoKGl0ZW0sIGluZGV4KSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgaWQ6IGAke2RvY1JlZi5pZH0taXRlbS0ke2luZGV4fWAsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBpdGVtLnRpdGxlLFxyXG4gICAgICAgICAgICAgICAgcXVhbnRpdHk6IGl0ZW0ucXVhbnRpdHksXHJcbiAgICAgICAgICAgICAgICBwcmljZTogaXRlbS5wcmljZVxyXG4gICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICB0b3RhbEFtb3VudDogb3JkZXJBbW91bnQsXHJcbiAgICAgICAgICAgICAgc3RhdHVzOiBvcmRlclN0YXR1cyA9PT0gJ1BFTkRJTkcnID8gJ1BlbmRpbmcnIDogXHJcbiAgICAgICAgICAgICAgICAgICAgIG9yZGVyU3RhdHVzID09PSAnQ09ORklSTUVEJyA/ICdDb25maXJtZWQnIDogJ1BlbmRpbmcnLFxyXG4gICAgICAgICAgICAgIGNyZWF0ZWRBdDogZmlyZXN0b3JlT3JkZXIuY3JlYXRlZEF0LFxyXG4gICAgICAgICAgICAgIC8vIEFkZGl0aW9uYWwgQ2hvcENob3Agc3BlY2lmaWMgZmllbGRzXHJcbiAgICAgICAgICAgICAgb3JkZXJJZDogb3JkZXJDb2RlLFxyXG4gICAgICAgICAgICAgIHJlc3RhdXJhbnRJZDogcmVzdGF1cmFudCxcclxuICAgICAgICAgICAgICBwYXltZW50TWV0aG9kLFxyXG4gICAgICAgICAgICAgIHBsYXRmb3JtOiAnQ2hvcENob3AnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCB2ZW5kb3JQYXRoID0gYGVhdGVyaWVzLyR7Y3VycmVudFZlbmRvclVJRH0vb3JkZXJzYDtcclxuICAgICAgICAgICAgY29uc3QgdmVuZG9yRG9jUmVmID0gYXdhaXQgYWRkRG9jKGNvbGxlY3Rpb24oZGIsICdlYXRlcmllcycsIGN1cnJlbnRWZW5kb3JVSUQsICdvcmRlcnMnKSwgdmVuZG9yT3JkZXJEYXRhKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgT3JkZXIgJHtvcmRlckNvZGV9IHNhdmVkIHRvIHZlbmRvciBwYXRoOiAke3ZlbmRvclBhdGh9IHdpdGggSUQ6ICR7dmVuZG9yRG9jUmVmLmlkfWApO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBPcmRlciBkYXRhIHNhdmVkOmAsIHZlbmRvck9yZGVyRGF0YSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46vIFZFUklGSUNBVElPTjogT3JkZXIgc2hvdWxkIGJlIHZpc2libGUgYXQgRmlyZWJhc2UgcGF0aDogZWF0ZXJpZXMvJHtjdXJyZW50VmVuZG9yVUlEfS9vcmRlcnMvJHt2ZW5kb3JEb2NSZWYuaWR9YCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyDwn5SEIFNZTkMgVE8gQ1VTVE9NRVIgT1JERVJTOiBTYXZlIG9yZGVyIHRvIGN1c3RvbWVyLWFjY2Vzc2libGUgY29sbGVjdGlvblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIC8vIElubGluZSBjdXN0b21lciBvcmRlciBzeW5jXHJcbiAgICAgICAgICAgICAgY29uc3QgY3VzdG9tZXJPcmRlckRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgICBvcmRlcklkOiBvcmRlckNvZGUsXHJcbiAgICAgICAgICAgICAgICBjdXN0b21lcklkOiB1c2VySWQgfHwgY3VzdG9tZXI/LmVtYWlsIHx8IGBjdXN0b21lci0ke0RhdGUubm93KCl9YCwgLy8gVXNlIHVzZXJJZCBpZiBhdmFpbGFibGUsIGZhbGxiYWNrIHRvIGVtYWlsXHJcbiAgICAgICAgICAgICAgICB2ZW5kb3JJZDogY3VycmVudFZlbmRvclVJRCxcclxuICAgICAgICAgICAgICAgIHJlc3RhdXJhbnRJZDogcmVzdGF1cmFudCxcclxuICAgICAgICAgICAgICAgIHJlc3RhdXJhbnROYW1lOiByZXN0YXVyYW50TmFtZSB8fCAnUmVzdGF1cmFudCcsXHJcbiAgICAgICAgICAgICAgICBjdXN0b21lcjoge1xyXG4gICAgICAgICAgICAgICAgICBuYW1lOiBjdXN0b21lcj8ubmFtZSB8fCAnQ2hvcENob3AgQ3VzdG9tZXInLFxyXG4gICAgICAgICAgICAgICAgICBlbWFpbDogY3VzdG9tZXI/LmVtYWlsIHx8ICdjdXN0b21lckBjaG9wY2hvcC5jb20nLFxyXG4gICAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzPy5kZWxpdmVyeUFkZHJlc3MgfHwgY3VzdG9tZXI/LmFkZHJlc3MgfHwgJ05vIGFkZHJlc3MgcHJvdmlkZWQnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaXRlbXM6IG9yZGVySW5wdXQubWFwKChpdGVtLCBpbmRleCkgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgaWQ6IGAke29yZGVyQ29kZX0taXRlbS0ke2luZGV4fWAsXHJcbiAgICAgICAgICAgICAgICAgIG5hbWU6IGl0ZW0udGl0bGUsXHJcbiAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBpdGVtLnF1YW50aXR5LFxyXG4gICAgICAgICAgICAgICAgICBwcmljZTogaXRlbS5wcmljZVxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IG9yZGVyQW1vdW50LFxyXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBvcmRlclN0YXR1cyA9PT0gJ1BFTkRJTkcnID8gJ1BlbmRpbmcnIDogXHJcbiAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJTdGF0dXMgPT09ICdDT05GSVJNRUQnID8gJ0NvbmZpcm1lZCcgOiAnUGVuZGluZycsXHJcbiAgICAgICAgICAgICAgICBwYXltZW50TWV0aG9kOiBwYXltZW50TWV0aG9kLFxyXG4gICAgICAgICAgICAgICAgY3JlYXRlZEF0OiBmaXJlc3RvcmVPcmRlci5jcmVhdGVkQXQsXHJcbiAgICAgICAgICAgICAgICB1cGRhdGVkQXQ6IGZpcmVzdG9yZU9yZGVyLmNyZWF0ZWRBdCxcclxuICAgICAgICAgICAgICAgIHRyYWNraW5nVXBkYXRlczogW1xyXG4gICAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzOiBvcmRlclN0YXR1cyA9PT0gJ1BFTkRJTkcnID8gJ1BlbmRpbmcnIDogXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yZGVyU3RhdHVzID09PSAnQ09ORklSTUVEJyA/ICdDb25maXJtZWQnIDogJ1BlbmRpbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgIHRpbWVzdGFtcDogZmlyZXN0b3JlT3JkZXIuY3JlYXRlZEF0LFxyXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IGBPcmRlciAke29yZGVyU3RhdHVzID09PSAnUEVORElORycgPyAncGVuZGluZycgOiBcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJTdGF0dXMgPT09ICdDT05GSVJNRUQnID8gJ2NvbmZpcm1lZCcgOiAncGVuZGluZyd9IGJ5IHJlc3RhdXJhbnRgLFxyXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiByZXN0YXVyYW50TmFtZSB8fCAnUmVzdGF1cmFudCdcclxuICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgXVxyXG4gICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgIGNvbnN0IGN1c3RvbWVyT3JkZXJSZWYgPSBhd2FpdCBhZGREb2MoXHJcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uKGRiLCAnY3VzdG9tZXItb3JkZXJzJyksIFxyXG4gICAgICAgICAgICAgICAgY3VzdG9tZXJPcmRlckRhdGFcclxuICAgICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEN1c3RvbWVyIG9yZGVyIHN5bmNlZDogY3VzdG9tZXItb3JkZXJzLyR7Y3VzdG9tZXJPcmRlclJlZi5pZH1gKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoc3luY0Vycm9yKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gRmFpbGVkIHRvIHN5bmMgY3VzdG9tZXIgb3JkZXI6Jywgc3luY0Vycm9yKTtcclxuICAgICAgICAgICAgICAvLyBEb24ndCBmYWlsIHRoZSBtYWluIG9yZGVyIC0gdGhpcyBpcyBzdXBwbGVtZW50YXJ5XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICB9IGNhdGNoIChwYXRoRXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS5lcnJvcihg4p2MIEZhaWxlZCB0byBzYXZlIHRvIHZlbmRvciBVSUQgJHtjdXJyZW50VmVuZG9yVUlEfTpgLCBwYXRoRXJyb3IpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gSU1QT1JUQU5UOiBMZXQncyBhbHNvIHRyeSB0byBzYXZlIHRvIGEgcHJlZGljdGFibGUgcGF0aCBmb3IgdGVzdGluZ1xyXG4gICAgICAgIC8vIFRoaXMgd2lsbCBoZWxwIHVzIGRlYnVnIHdoYXQncyBoYXBwZW5pbmdcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgZGVidWdPcmRlckRhdGEgPSB7XHJcbiAgICAgICAgICAgIGlkOiBkb2NSZWYuaWQsXHJcbiAgICAgICAgICAgIGVhdGVyeUlkOiAnREVCVUdfVkVORE9SJyxcclxuICAgICAgICAgICAgY3VzdG9tZXI6IHsgbmFtZTogJ0RlYnVnIEN1c3RvbWVyJywgZW1haWw6ICdkZWJ1Z0B0ZXN0LmNvbScsIGFkZHJlc3M6ICdEZWJ1ZyBBZGRyZXNzJyB9LFxyXG4gICAgICAgICAgICBpdGVtczogW3sgaWQ6ICdkZWJ1Zy1pdGVtJywgbmFtZTogJ0RlYnVnIEl0ZW0nLCBxdWFudGl0eTogMSwgcHJpY2U6IDEwLjk5IH1dLFxyXG4gICAgICAgICAgICB0b3RhbEFtb3VudDogMTAuOTksXHJcbiAgICAgICAgICAgIHN0YXR1czogJ1BlbmRpbmcnLFxyXG4gICAgICAgICAgICBjcmVhdGVkQXQ6IGZpcmVzdG9yZU9yZGVyLmNyZWF0ZWRBdCxcclxuICAgICAgICAgICAgZGVidWdJbmZvOiB7XHJcbiAgICAgICAgICAgICAgb3JpZ2luYWxSZXN0YXVyYW50SWQ6IHJlc3RhdXJhbnQsXHJcbiAgICAgICAgICAgICAgb3JkZXJDb2RlOiBvcmRlckNvZGUsXHJcbiAgICAgICAgICAgICAgdGltZXN0YW1wOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgICAgICAgc291cmNlOiAnQ2hvcENob3AgRGVidWcgU2F2ZSdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgYXdhaXQgYWRkRG9jKGNvbGxlY3Rpb24oZGIsICdlYXRlcmllcycsICdERUJVR19WRU5ET1InLCAnb3JkZXJzJyksIGRlYnVnT3JkZXJEYXRhKTtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5CbIERFQlVHOiBPcmRlciBzYXZlZCB0byBlYXRlcmllcy9ERUJVR19WRU5ET1Ivb3JkZXJzIGZvciB0ZXN0aW5nYCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICB9IGNhdGNoIChkZWJ1Z0Vycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ0RlYnVnIHNhdmUgZmFpbGVkOicsIGRlYnVnRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgfSBjYXRjaCAodmVuZG9yRXJyb3IpIHtcclxuICAgICAgICBjb25zb2xlLmVycm9yKCfimqDvuI8gRmFpbGVkIHRvIHNhdmUgdG8gdmVuZG9yIGNvbGxlY3Rpb25zOicsIHZlbmRvckVycm9yKTtcclxuICAgICAgICAvLyBEb24ndCB0aHJvdyAtIGdsb2JhbCBvcmRlciB3YXMgc2F2ZWQgc3VjY2Vzc2Z1bGx5XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgb3JkZXJJZDogb3JkZXJDb2RlLFxyXG4gICAgICAgIG9yZGVyU3RhdHVzLFxyXG4gICAgICAgIHRvdGFsOiBvcmRlckFtb3VudCxcclxuICAgICAgICBmaXJlYmFzZUlkOiBkb2NSZWYuaWRcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRmlyZWJhc2Ugb3JkZXIgY3JlYXRpb24gZmFpbGVkOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGxhY2Ugb3JkZXI6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHN0YXRpYyBhc3luYyB1cGRhdGVPcmRlclN0YXR1cyhmaXJlYmFzZUlkOiBzdHJpbmcsIHN0YXR1czogc3RyaW5nLCBwYWlkQW1vdW50PzogbnVtYmVyKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCB7IHVwZGF0ZURvYywgZG9jIH0gPSBhd2FpdCBpbXBvcnQoJ2ZpcmViYXNlL2ZpcmVzdG9yZScpO1xyXG4gICAgICBjb25zdCBvcmRlclJlZiA9IGRvYyhkYiwgJ29yZGVycycsIGZpcmViYXNlSWQpO1xyXG4gICAgICBcclxuICAgICAgY29uc3QgdXBkYXRlRGF0YTogYW55ID0ge1xyXG4gICAgICAgIG9yZGVyU3RhdHVzOiBzdGF0dXMsXHJcbiAgICAgICAgdXBkYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKVxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgICAgaWYgKHBhaWRBbW91bnQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHVwZGF0ZURhdGEucGFpZEFtb3VudCA9IHBhaWRBbW91bnQ7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGF3YWl0IHVwZGF0ZURvYyhvcmRlclJlZiwgdXBkYXRlRGF0YSk7XHJcbiAgICAgIGNvbnNvbGUubG9nKGDinIUgT3JkZXIgJHtmaXJlYmFzZUlkfSBzdGF0dXMgdXBkYXRlZCB0byAke3N0YXR1c31gKTtcclxuICAgICAgXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRmlyZWJhc2Ugb3JkZXIgdXBkYXRlIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IGVycm9yO1xyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgT3JkZXJTZXJ2aWNlOyJdLCJuYW1lcyI6WyJnZXRGaXJlc3RvcmUiLCJjb2xsZWN0aW9uIiwiYWRkRG9jIiwic2VydmVyVGltZXN0YW1wIiwiZ2V0RG9jcyIsImRvYyIsInNldERvYyIsImdldEZpcmViYXNlQXBwIiwiZGIiLCJPcmRlclNlcnZpY2UiLCJwbGFjZU9yZGVyIiwicmVzdGF1cmFudCIsInJlc3RhdXJhbnROYW1lIiwib3JkZXJJbnB1dCIsInBheW1lbnRNZXRob2QiLCJhZGRyZXNzIiwiY3VzdG9tZXIiLCJkZWxpdmVyeUNoYXJnZXMiLCJ0aXBwaW5nIiwidGF4YXRpb25BbW91bnQiLCJpbnN0cnVjdGlvbnMiLCJpc1BpY2tlZFVwIiwidXNlcklkIiwic3VidG90YWwiLCJyZWR1Y2UiLCJzdW0iLCJpdGVtIiwicHJpY2UiLCJxdWFudGl0eSIsIm9yZGVyQW1vdW50Iiwib3JkZXJTdGF0dXMiLCJwYWlkQW1vdW50Iiwib3JkZXJDb2RlIiwiRGF0ZSIsIm5vdyIsImZpcmVzdG9yZU9yZGVyIiwib3JkZXJJZCIsInJlc3RhdXJhbnRJZCIsIm9yZGVyRGF0ZSIsInRvSVNPU3RyaW5nIiwiY3JlYXRlZEF0IiwiaXRlbXMiLCJ2ZW5kb3JOb3RpZmllZCIsIm9yZGVyVHlwZSIsInBsYXRmb3JtIiwiZGVsaXZlcnlBZGRyZXNzIiwibGF0aXR1ZGUiLCJ1bmRlZmluZWQiLCJkZWxpdmVyeUxhdGl0dWRlIiwibG9uZ2l0dWRlIiwiZGVsaXZlcnlMb25naXR1ZGUiLCJkb2NSZWYiLCJjb25zb2xlIiwibG9nIiwiaWQiLCJ2ZW5kb3JVSUQiLCJlYXRlcmllc1NuYXBzaG90IiwiZG9jcyIsImVhdGVyeURhdGEiLCJkYXRhIiwicmVzdGF1cmFudElkcyIsImluY2x1ZGVzIiwibG9va3VwRXJyb3IiLCJ3YXJuIiwidmVuZG9yVUlEcyIsInB1c2giLCJhbGxFYXRlcmllc1NuYXBzaG90IiwibGVuZ3RoIiwiYWxsVmVuZG9yVUlEcyIsIm1hcCIsImFsbFZlbmRvcnNFcnJvciIsImN1cnJlbnRWZW5kb3JVSUQiLCJlYXRlcnlEb2NSZWYiLCJuYW1lIiwiZW1haWwiLCJtZXJnZSIsInZlbmRvck9yZGVyRGF0YSIsImVhdGVyeUlkIiwiaW5kZXgiLCJ0aXRsZSIsInRvdGFsQW1vdW50Iiwic3RhdHVzIiwidmVuZG9yUGF0aCIsInZlbmRvckRvY1JlZiIsImN1c3RvbWVyT3JkZXJEYXRhIiwiY3VzdG9tZXJJZCIsInZlbmRvcklkIiwidXBkYXRlZEF0IiwidHJhY2tpbmdVcGRhdGVzIiwidGltZXN0YW1wIiwibWVzc2FnZSIsImxvY2F0aW9uIiwiY3VzdG9tZXJPcmRlclJlZiIsInN5bmNFcnJvciIsInBhdGhFcnJvciIsImVycm9yIiwiZGVidWdPcmRlckRhdGEiLCJkZWJ1Z0luZm8iLCJvcmlnaW5hbFJlc3RhdXJhbnRJZCIsInNvdXJjZSIsImRlYnVnRXJyb3IiLCJ2ZW5kb3JFcnJvciIsInRvdGFsIiwiZmlyZWJhc2VJZCIsIkVycm9yIiwidXBkYXRlT3JkZXJTdGF0dXMiLCJ1cGRhdGVEb2MiLCJvcmRlclJlZiIsInVwZGF0ZURhdGEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/firebase/orders.ts\n"));

/***/ })

});