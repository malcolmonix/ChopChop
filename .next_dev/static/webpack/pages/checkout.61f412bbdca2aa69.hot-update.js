"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/checkout",{

/***/ "./lib/firebase/orders.ts":
/*!********************************!*\
  !*** ./lib/firebase/orders.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrderService: function() { return /* binding */ OrderService; }\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client */ \"./lib/firebase/client.ts\");\n\n\n// Initialize Firestore\nconst db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getFirestore)((0,_client__WEBPACK_IMPORTED_MODULE_1__.getFirebaseApp)());\nclass OrderService {\n    static async placeOrder(param) {\n        let { restaurant, restaurantName, orderInput, paymentMethod, address, customer, deliveryCharges = 0, tipping = 0, taxationAmount = 0, instructions = \"\", isPickedUp = false } = param;\n        try {\n            // Calculate order details\n            const subtotal = orderInput.reduce((sum, item)=>sum + item.price * item.quantity, 0);\n            const orderAmount = subtotal + deliveryCharges + tipping + taxationAmount;\n            // Determine order status based on payment method\n            let orderStatus = \"PENDING\";\n            let paidAmount = 0;\n            if (paymentMethod === \"CASH\") {\n                orderStatus = \"PENDING\"; // Will be paid on delivery\n                paidAmount = 0;\n            } else if (paymentMethod === \"CARD\" || paymentMethod === \"WALLET\") {\n                orderStatus = \"CONFIRMED\"; // Electronic payments - assume paid immediately\n                paidAmount = orderAmount;\n            } else if (paymentMethod === \"BANK\") {\n                orderStatus = \"PAYMENT_PENDING\"; // Bank transfer - awaiting verification\n                paidAmount = 0;\n            }\n            const orderCode = \"CC\".concat(Date.now());\n            // Create Firebase order object (removing undefined values)\n            const firestoreOrder = {\n                orderId: orderCode,\n                restaurantId: restaurant,\n                orderStatus,\n                paymentMethod,\n                orderAmount,\n                paidAmount,\n                deliveryCharges,\n                tipping,\n                taxationAmount,\n                orderDate: new Date().toISOString(),\n                isPickedUp,\n                createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                items: orderInput,\n                // Vendor notification fields for MenuVerse integration\n                vendorNotified: false,\n                orderType: \"delivery\",\n                platform: \"ChopChop\"\n            };\n            // Only add optional fields if they have values\n            if (address === null || address === void 0 ? void 0 : address.deliveryAddress) {\n                firestoreOrder.deliveryAddress = address.deliveryAddress;\n            }\n            if ((address === null || address === void 0 ? void 0 : address.latitude) !== undefined) {\n                firestoreOrder.deliveryLatitude = address.latitude;\n            }\n            if ((address === null || address === void 0 ? void 0 : address.longitude) !== undefined) {\n                firestoreOrder.deliveryLongitude = address.longitude;\n            }\n            if (instructions) {\n                firestoreOrder.instructions = instructions;\n            }\n            // Save to Firebase orders collection\n            const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"orders\"), firestoreOrder);\n            console.log(\"‚úÖ Order \".concat(orderCode, \" saved to Firebase with ID:\"), docRef.id);\n            // ALSO save to vendor-specific collection for MenuVerse notifications\n            console.log(\"\\uD83D\\uDE80 STARTING vendor save process for order \".concat(orderCode, \"...\"));\n            try {\n                // Dynamic restaurant-to-vendor mapping\n                // In production, this would come from a database lookup\n                // For now, we'll try to find the vendor UID dynamically\n                console.log(\"\\uD83D\\uDD0D Looking up vendor for restaurant ID: \".concat(restaurant));\n                // Method 1: Try to find vendor by querying the eateries collection\n                let vendorUID = null;\n                try {\n                    // Query the eateries collection to find which vendor owns this restaurant\n                    const eateriesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"eateries\"));\n                    for (const doc of eateriesSnapshot.docs){\n                        const eateryData = doc.data();\n                        // Check if this eatery has this restaurant ID\n                        // This assumes the eatery document has a restaurantIds array or similar\n                        if (eateryData.restaurantIds && eateryData.restaurantIds.includes(restaurant)) {\n                            vendorUID = doc.id;\n                            console.log(\"‚úÖ Found vendor \".concat(vendorUID, \" for restaurant \").concat(restaurant));\n                            break;\n                        }\n                        // Alternative: check if restaurant ID matches the eatery ID\n                        if (eateryData.id === restaurant || eateryData.restaurantId === restaurant) {\n                            vendorUID = doc.id;\n                            console.log(\"‚úÖ Found vendor \".concat(vendorUID, \" for restaurant \").concat(restaurant, \" (direct match)\"));\n                            break;\n                        }\n                    }\n                } catch (lookupError) {\n                    console.warn(\"‚ö†Ô∏è Could not lookup vendor from eateries collection:\", lookupError);\n                }\n                // Method 2: If no specific mapping found, save to all active vendors\n                // This ensures orders don't get lost while the mapping system is being set up\n                const vendorUIDs = [];\n                if (vendorUID) {\n                    vendorUIDs.push(vendorUID);\n                } else {\n                    console.log(\"\\uD83D\\uDD04 No specific vendor found for restaurant \".concat(restaurant, \", will save to all active vendors\"));\n                    // Get all vendor UIDs from eateries collection\n                    try {\n                        const allEateriesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"eateries\"));\n                        if (allEateriesSnapshot.docs.length > 0) {\n                            const allVendorUIDs = allEateriesSnapshot.docs.map((doc)=>doc.id);\n                            vendorUIDs.push(...allVendorUIDs);\n                            console.log(\"\\uD83D\\uDCCB Found \".concat(allVendorUIDs.length, \" active vendors:\"), allVendorUIDs);\n                        } else {\n                            console.log(\"\\uD83D\\uDCED No eateries collection found. Creating vendor entry for current demo user.\");\n                            // If no eateries exist, create one for the demo vendor\n                            vendorUIDs.push(\"0GI3MojVnLfvzSEqMc25oCzAmCz2\");\n                        }\n                    } catch (allVendorsError) {\n                        console.warn(\"‚ö†Ô∏è Could not get all vendors, using fallback UIDs\");\n                        // Fallback to known UIDs if the query fails\n                        vendorUIDs.push(\"0GI3MojVnLfvzSEqMc25oCzAmCz2\"); // Current demo vendor\n                    }\n                }\n                console.log(\"\\uD83C\\uDFAF Will save order to \".concat(vendorUIDs.length, \" vendor(s):\"), vendorUIDs);\n                // Save order to each vendor's collection\n                for (const currentVendorUID of vendorUIDs){\n                    try {\n                        // First, ensure the vendor's eatery document exists\n                        const eateryDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(db, \"eateries\", currentVendorUID);\n                        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)(eateryDocRef, {\n                            id: currentVendorUID,\n                            name: restaurantName || \"Restaurant\",\n                            email: \"vendor@chopchop.com\",\n                            createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                            restaurantIds: [\n                                restaurant\n                            ] // Map this vendor to this restaurant\n                        }, {\n                            merge: true\n                        }); // merge: true means only update if document doesn't exist\n                        console.log(\"‚úÖ Ensured eatery document exists for vendor: \".concat(currentVendorUID));\n                        const vendorOrderData = {\n                            // Use the exact same structure that MenuVerse expects\n                            id: docRef.id,\n                            eateryId: currentVendorUID,\n                            customer: {\n                                name: (customer === null || customer === void 0 ? void 0 : customer.name) || \"ChopChop Customer\",\n                                email: (customer === null || customer === void 0 ? void 0 : customer.email) || \"customer@chopchop.com\",\n                                address: (address === null || address === void 0 ? void 0 : address.deliveryAddress) || (customer === null || customer === void 0 ? void 0 : customer.address) || \"No address provided\"\n                            },\n                            items: orderInput.map((item, index)=>({\n                                    id: \"\".concat(docRef.id, \"-item-\").concat(index),\n                                    name: item.title,\n                                    quantity: item.quantity,\n                                    price: item.price\n                                })),\n                            totalAmount: orderAmount,\n                            status: orderStatus === \"PENDING\" ? \"Pending\" : orderStatus === \"CONFIRMED\" ? \"Confirmed\" : \"Pending\",\n                            createdAt: firestoreOrder.createdAt,\n                            // Additional ChopChop specific fields\n                            orderId: orderCode,\n                            restaurantId: restaurant,\n                            paymentMethod,\n                            platform: \"ChopChop\"\n                        };\n                        const vendorPath = \"eateries/\".concat(currentVendorUID, \"/orders\");\n                        const vendorDocRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"eateries\", currentVendorUID, \"orders\"), vendorOrderData);\n                        console.log(\"‚úÖ Order \".concat(orderCode, \" saved to vendor path: \").concat(vendorPath, \" with ID: \").concat(vendorDocRef.id));\n                        console.log(\"\\uD83D\\uDCCA Order data saved:\", vendorOrderData);\n                        console.log(\"\\uD83C\\uDFAF VERIFICATION: Order should be visible at Firebase path: eateries/\".concat(currentVendorUID, \"/orders/\").concat(vendorDocRef.id));\n                    // üîÑ SYNC TO CUSTOMER ORDERS: Save order to customer-accessible collection\n                    // Temporarily disabled to fix build issue\n                    /*\r\n            try {\r\n              const customerOrderId = await OrderSyncService.saveCustomerOrder({\r\n                orderId: orderCode,\r\n                customerId: customer?.email || `customer-${Date.now()}`, // Use email as customer ID\r\n                vendorId: currentVendorUID,\r\n                restaurantId: restaurant,\r\n                restaurantName: restaurantName || 'Restaurant', // Use actual restaurant name\r\n                customer: {\r\n                  name: customer?.name || 'ChopChop Customer',\r\n                  email: customer?.email || 'customer@chopchop.com',\r\n                  address: address?.deliveryAddress || customer?.address || 'No address provided'\r\n                },\r\n                items: orderInput.map((item, index) => ({\r\n                  id: `${orderCode}-item-${index}`,\r\n                  name: item.title,\r\n                  quantity: item.quantity,\r\n                  price: item.price\r\n                })),\r\n                totalAmount: orderAmount,\r\n                status: orderStatus === 'PENDING' ? 'Pending' : \r\n                       orderStatus === 'CONFIRMED' ? 'Confirmed' : 'Pending',\r\n                paymentMethod: paymentMethod\r\n              });\r\n              \r\n              if (customerOrderId) {\r\n                console.log(`‚úÖ Customer order synced: customer-orders/${customerOrderId}`);\r\n              }\r\n            } catch (syncError) {\r\n              console.warn('‚ö†Ô∏è Failed to sync customer order:', syncError);\r\n              // Don't fail the main order - this is supplementary\r\n            }\r\n            */ } catch (pathError) {\n                        console.error(\"‚ùå Failed to save to vendor UID \".concat(currentVendorUID, \":\"), pathError);\n                    }\n                }\n                // IMPORTANT: Let's also try to save to a predictable path for testing\n                // This will help us debug what's happening\n                try {\n                    const debugOrderData = {\n                        id: docRef.id,\n                        eateryId: \"DEBUG_VENDOR\",\n                        customer: {\n                            name: \"Debug Customer\",\n                            email: \"debug@test.com\",\n                            address: \"Debug Address\"\n                        },\n                        items: [\n                            {\n                                id: \"debug-item\",\n                                name: \"Debug Item\",\n                                quantity: 1,\n                                price: 10.99\n                            }\n                        ],\n                        totalAmount: 10.99,\n                        status: \"Pending\",\n                        createdAt: firestoreOrder.createdAt,\n                        debugInfo: {\n                            originalRestaurantId: restaurant,\n                            orderCode: orderCode,\n                            timestamp: new Date().toISOString(),\n                            source: \"ChopChop Debug Save\"\n                        }\n                    };\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"eateries\", \"DEBUG_VENDOR\", \"orders\"), debugOrderData);\n                    console.log(\"\\uD83D\\uDC1B DEBUG: Order saved to eateries/DEBUG_VENDOR/orders for testing\");\n                } catch (debugError) {\n                    console.warn(\"Debug save failed:\", debugError);\n                }\n            } catch (vendorError) {\n                console.error(\"‚ö†Ô∏è Failed to save to vendor collections:\", vendorError);\n            // Don't throw - global order was saved successfully\n            }\n            return {\n                orderId: orderCode,\n                orderStatus,\n                total: orderAmount,\n                firebaseId: docRef.id\n            };\n        } catch (error) {\n            console.error(\"‚ùå Firebase order creation failed:\", error);\n            throw new Error(\"Failed to place order: \".concat(error.message));\n        }\n    }\n    static async updateOrderStatus(firebaseId, status, paidAmount) {\n        try {\n            const { updateDoc, doc } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! firebase/firestore */ \"./node_modules/firebase/firestore/dist/esm/index.esm.js\"));\n            const orderRef = doc(db, \"orders\", firebaseId);\n            const updateData = {\n                orderStatus: status,\n                updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n            };\n            if (paidAmount !== undefined) {\n                updateData.paidAmount = paidAmount;\n            }\n            await updateDoc(orderRef, updateData);\n            console.log(\"‚úÖ Order \".concat(firebaseId, \" status updated to \").concat(status));\n        } catch (error) {\n            console.error(\"‚ùå Firebase order update failed:\", error);\n            throw error;\n        }\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (OrderService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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LFdBQVc3RixJQUFJRyxJQUFJLFVBQVVxRjtZQUVuQyxNQUFNTSxhQUFrQjtnQkFDdEJ0RSxhQUFhbUQ7Z0JBQ2JvQixXQUFXakcsbUVBQWVBO1lBQzVCO1lBRUEsSUFBSTJCLGVBQWVnQixXQUFXO2dCQUM1QnFELFdBQVdyRSxVQUFVLEdBQUdBO1lBQzFCO1lBRUEsTUFBTW1FLFVBQVVDLFVBQVVDO1lBQzFCaEQsUUFBUUMsR0FBRyxDQUFDLFdBQTJDNEIsT0FBaENhLFlBQVcsdUJBQTRCLE9BQVBiO1FBRXpELEVBQUUsT0FBT0ksT0FBTztZQUNkakMsUUFBUWlDLEtBQUssQ0FBQyxtQ0FBbUNBO1lBQ2pELE1BQU1BO1FBQ1I7SUFDRjtBQUNGO0FBRUEsK0RBQWUzRSxZQUFZQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2xpYi9maXJlYmFzZS9vcmRlcnMudHM/MDk0YyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXRGaXJlc3RvcmUsIGNvbGxlY3Rpb24sIGFkZERvYywgc2VydmVyVGltZXN0YW1wLCBnZXREb2NzLCBkb2MsIHNldERvYyB9IGZyb20gJ2ZpcmViYXNlL2ZpcmVzdG9yZSc7XHJcbmltcG9ydCB7IGdldEZpcmViYXNlQXBwIH0gZnJvbSAnLi9jbGllbnQnO1xyXG5pbXBvcnQgeyBPcmRlclN5bmNTZXJ2aWNlIH0gZnJvbSAnLi9vcmRlci1zeW5jJztcclxuXHJcbi8vIEluaXRpYWxpemUgRmlyZXN0b3JlXHJcbmNvbnN0IGRiID0gZ2V0RmlyZXN0b3JlKGdldEZpcmViYXNlQXBwKCkpO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPcmRlckl0ZW0ge1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgcXVhbnRpdHk6IG51bWJlcjtcclxuICBwcmljZTogbnVtYmVyO1xyXG4gIHZhcmlhdGlvbj86IHN0cmluZztcclxuICBhZGRvbnM/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgT3JkZXJBZGRyZXNzIHtcclxuICBkZWxpdmVyeUFkZHJlc3M6IHN0cmluZztcclxuICBsYXRpdHVkZT86IG51bWJlcjtcclxuICBsb25naXR1ZGU/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRmlyZWJhc2VPcmRlciB7XHJcbiAgb3JkZXJJZDogc3RyaW5nO1xyXG4gIHJlc3RhdXJhbnRJZDogbnVtYmVyO1xyXG4gIG9yZGVyU3RhdHVzOiBzdHJpbmc7XHJcbiAgcGF5bWVudE1ldGhvZDogc3RyaW5nO1xyXG4gIG9yZGVyQW1vdW50OiBudW1iZXI7XHJcbiAgcGFpZEFtb3VudDogbnVtYmVyO1xyXG4gIGRlbGl2ZXJ5QWRkcmVzcz86IHN0cmluZztcclxuICBkZWxpdmVyeUxhdGl0dWRlPzogbnVtYmVyO1xyXG4gIGRlbGl2ZXJ5TG9uZ2l0dWRlPzogbnVtYmVyO1xyXG4gIGluc3RydWN0aW9ucz86IHN0cmluZztcclxuICBkZWxpdmVyeUNoYXJnZXM6IG51bWJlcjtcclxuICB0aXBwaW5nOiBudW1iZXI7XHJcbiAgdGF4YXRpb25BbW91bnQ6IG51bWJlcjtcclxuICBvcmRlckRhdGU6IHN0cmluZztcclxuICBpc1BpY2tlZFVwOiBib29sZWFuO1xyXG4gIGNyZWF0ZWRBdDogYW55OyAvLyBzZXJ2ZXJUaW1lc3RhbXBcclxuICBpdGVtczogT3JkZXJJdGVtW107XHJcbiAgdmVuZG9yTm90aWZpZWQ6IGJvb2xlYW47XHJcbiAgb3JkZXJUeXBlOiBzdHJpbmc7XHJcbiAgcGxhdGZvcm06IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE9yZGVyU2VydmljZSB7XHJcbiAgc3RhdGljIGFzeW5jIHBsYWNlT3JkZXIoe1xyXG4gICAgcmVzdGF1cmFudCxcclxuICAgIHJlc3RhdXJhbnROYW1lLFxyXG4gICAgb3JkZXJJbnB1dCxcclxuICAgIHBheW1lbnRNZXRob2QsXHJcbiAgICBhZGRyZXNzLFxyXG4gICAgY3VzdG9tZXIsXHJcbiAgICBkZWxpdmVyeUNoYXJnZXMgPSAwLFxyXG4gICAgdGlwcGluZyA9IDAsXHJcbiAgICB0YXhhdGlvbkFtb3VudCA9IDAsXHJcbiAgICBpbnN0cnVjdGlvbnMgPSAnJyxcclxuICAgIGlzUGlja2VkVXAgPSBmYWxzZVxyXG4gIH06IHtcclxuICAgIHJlc3RhdXJhbnQ6IG51bWJlcjtcclxuICAgIHJlc3RhdXJhbnROYW1lPzogc3RyaW5nO1xyXG4gICAgb3JkZXJJbnB1dDogT3JkZXJJdGVtW107XHJcbiAgICBwYXltZW50TWV0aG9kOiBzdHJpbmc7XHJcbiAgICBhZGRyZXNzPzogT3JkZXJBZGRyZXNzO1xyXG4gICAgY3VzdG9tZXI/OiB7XHJcbiAgICAgIG5hbWU6IHN0cmluZztcclxuICAgICAgZW1haWw6IHN0cmluZztcclxuICAgICAgYWRkcmVzcz86IHN0cmluZztcclxuICAgIH07XHJcbiAgICBkZWxpdmVyeUNoYXJnZXM/OiBudW1iZXI7XHJcbiAgICB0aXBwaW5nPzogbnVtYmVyO1xyXG4gICAgdGF4YXRpb25BbW91bnQ/OiBudW1iZXI7XHJcbiAgICBpbnN0cnVjdGlvbnM/OiBzdHJpbmc7XHJcbiAgICBpc1BpY2tlZFVwPzogYm9vbGVhbjtcclxuICB9KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBDYWxjdWxhdGUgb3JkZXIgZGV0YWlsc1xyXG4gICAgICBjb25zdCBzdWJ0b3RhbCA9IG9yZGVySW5wdXQucmVkdWNlKChzdW0sIGl0ZW0pID0+IHN1bSArIChpdGVtLnByaWNlICogaXRlbS5xdWFudGl0eSksIDApO1xyXG4gICAgICBjb25zdCBvcmRlckFtb3VudCA9IHN1YnRvdGFsICsgZGVsaXZlcnlDaGFyZ2VzICsgdGlwcGluZyArIHRheGF0aW9uQW1vdW50O1xyXG4gICAgICBcclxuICAgICAgLy8gRGV0ZXJtaW5lIG9yZGVyIHN0YXR1cyBiYXNlZCBvbiBwYXltZW50IG1ldGhvZFxyXG4gICAgICBsZXQgb3JkZXJTdGF0dXMgPSAnUEVORElORyc7XHJcbiAgICAgIGxldCBwYWlkQW1vdW50ID0gMDtcclxuICAgICAgXHJcbiAgICAgIGlmIChwYXltZW50TWV0aG9kID09PSAnQ0FTSCcpIHtcclxuICAgICAgICBvcmRlclN0YXR1cyA9ICdQRU5ESU5HJzsgLy8gV2lsbCBiZSBwYWlkIG9uIGRlbGl2ZXJ5XHJcbiAgICAgICAgcGFpZEFtb3VudCA9IDA7XHJcbiAgICAgIH0gZWxzZSBpZiAocGF5bWVudE1ldGhvZCA9PT0gJ0NBUkQnIHx8IHBheW1lbnRNZXRob2QgPT09ICdXQUxMRVQnKSB7XHJcbiAgICAgICAgb3JkZXJTdGF0dXMgPSAnQ09ORklSTUVEJzsgLy8gRWxlY3Ryb25pYyBwYXltZW50cyAtIGFzc3VtZSBwYWlkIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgcGFpZEFtb3VudCA9IG9yZGVyQW1vdW50O1xyXG4gICAgICB9IGVsc2UgaWYgKHBheW1lbnRNZXRob2QgPT09ICdCQU5LJykge1xyXG4gICAgICAgIG9yZGVyU3RhdHVzID0gJ1BBWU1FTlRfUEVORElORyc7IC8vIEJhbmsgdHJhbnNmZXIgLSBhd2FpdGluZyB2ZXJpZmljYXRpb25cclxuICAgICAgICBwYWlkQW1vdW50ID0gMDtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3Qgb3JkZXJDb2RlID0gYENDJHtEYXRlLm5vdygpfWA7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDcmVhdGUgRmlyZWJhc2Ugb3JkZXIgb2JqZWN0IChyZW1vdmluZyB1bmRlZmluZWQgdmFsdWVzKVxyXG4gICAgICBjb25zdCBmaXJlc3RvcmVPcmRlcjogYW55ID0ge1xyXG4gICAgICAgIG9yZGVySWQ6IG9yZGVyQ29kZSxcclxuICAgICAgICByZXN0YXVyYW50SWQ6IHJlc3RhdXJhbnQsXHJcbiAgICAgICAgb3JkZXJTdGF0dXMsXHJcbiAgICAgICAgcGF5bWVudE1ldGhvZCxcclxuICAgICAgICBvcmRlckFtb3VudCxcclxuICAgICAgICBwYWlkQW1vdW50LFxyXG4gICAgICAgIGRlbGl2ZXJ5Q2hhcmdlcyxcclxuICAgICAgICB0aXBwaW5nLFxyXG4gICAgICAgIHRheGF0aW9uQW1vdW50LFxyXG4gICAgICAgIG9yZGVyRGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIGlzUGlja2VkVXAsXHJcbiAgICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcclxuICAgICAgICBpdGVtczogb3JkZXJJbnB1dCxcclxuICAgICAgICAvLyBWZW5kb3Igbm90aWZpY2F0aW9uIGZpZWxkcyBmb3IgTWVudVZlcnNlIGludGVncmF0aW9uXHJcbiAgICAgICAgdmVuZG9yTm90aWZpZWQ6IGZhbHNlLFxyXG4gICAgICAgIG9yZGVyVHlwZTogJ2RlbGl2ZXJ5JyxcclxuICAgICAgICBwbGF0Zm9ybTogJ0Nob3BDaG9wJ1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gT25seSBhZGQgb3B0aW9uYWwgZmllbGRzIGlmIHRoZXkgaGF2ZSB2YWx1ZXNcclxuICAgICAgaWYgKGFkZHJlc3M/LmRlbGl2ZXJ5QWRkcmVzcykge1xyXG4gICAgICAgIGZpcmVzdG9yZU9yZGVyLmRlbGl2ZXJ5QWRkcmVzcyA9IGFkZHJlc3MuZGVsaXZlcnlBZGRyZXNzO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhZGRyZXNzPy5sYXRpdHVkZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZmlyZXN0b3JlT3JkZXIuZGVsaXZlcnlMYXRpdHVkZSA9IGFkZHJlc3MubGF0aXR1ZGU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGFkZHJlc3M/LmxvbmdpdHVkZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZmlyZXN0b3JlT3JkZXIuZGVsaXZlcnlMb25naXR1ZGUgPSBhZGRyZXNzLmxvbmdpdHVkZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaW5zdHJ1Y3Rpb25zKSB7XHJcbiAgICAgICAgZmlyZXN0b3JlT3JkZXIuaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBTYXZlIHRvIEZpcmViYXNlIG9yZGVycyBjb2xsZWN0aW9uXHJcbiAgICAgIGNvbnN0IGRvY1JlZiA9IGF3YWl0IGFkZERvYyhjb2xsZWN0aW9uKGRiLCAnb3JkZXJzJyksIGZpcmVzdG9yZU9yZGVyKTtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBPcmRlciAke29yZGVyQ29kZX0gc2F2ZWQgdG8gRmlyZWJhc2Ugd2l0aCBJRDpgLCBkb2NSZWYuaWQpO1xyXG5cclxuICAgICAgLy8gQUxTTyBzYXZlIHRvIHZlbmRvci1zcGVjaWZpYyBjb2xsZWN0aW9uIGZvciBNZW51VmVyc2Ugbm90aWZpY2F0aW9uc1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+agCBTVEFSVElORyB2ZW5kb3Igc2F2ZSBwcm9jZXNzIGZvciBvcmRlciAke29yZGVyQ29kZX0uLi5gKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBEeW5hbWljIHJlc3RhdXJhbnQtdG8tdmVuZG9yIG1hcHBpbmdcclxuICAgICAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGNvbWUgZnJvbSBhIGRhdGFiYXNlIGxvb2t1cFxyXG4gICAgICAgIC8vIEZvciBub3csIHdlJ2xsIHRyeSB0byBmaW5kIHRoZSB2ZW5kb3IgVUlEIGR5bmFtaWNhbGx5XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coYPCflI0gTG9va2luZyB1cCB2ZW5kb3IgZm9yIHJlc3RhdXJhbnQgSUQ6ICR7cmVzdGF1cmFudH1gKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBNZXRob2QgMTogVHJ5IHRvIGZpbmQgdmVuZG9yIGJ5IHF1ZXJ5aW5nIHRoZSBlYXRlcmllcyBjb2xsZWN0aW9uXHJcbiAgICAgICAgbGV0IHZlbmRvclVJRDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIFF1ZXJ5IHRoZSBlYXRlcmllcyBjb2xsZWN0aW9uIHRvIGZpbmQgd2hpY2ggdmVuZG9yIG93bnMgdGhpcyByZXN0YXVyYW50XHJcbiAgICAgICAgICBjb25zdCBlYXRlcmllc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhjb2xsZWN0aW9uKGRiLCAnZWF0ZXJpZXMnKSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGZvciAoY29uc3QgZG9jIG9mIGVhdGVyaWVzU25hcHNob3QuZG9jcykge1xyXG4gICAgICAgICAgICBjb25zdCBlYXRlcnlEYXRhID0gZG9jLmRhdGEoKTtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBlYXRlcnkgaGFzIHRoaXMgcmVzdGF1cmFudCBJRFxyXG4gICAgICAgICAgICAvLyBUaGlzIGFzc3VtZXMgdGhlIGVhdGVyeSBkb2N1bWVudCBoYXMgYSByZXN0YXVyYW50SWRzIGFycmF5IG9yIHNpbWlsYXJcclxuICAgICAgICAgICAgaWYgKGVhdGVyeURhdGEucmVzdGF1cmFudElkcyAmJiBlYXRlcnlEYXRhLnJlc3RhdXJhbnRJZHMuaW5jbHVkZXMocmVzdGF1cmFudCkpIHtcclxuICAgICAgICAgICAgICB2ZW5kb3JVSUQgPSBkb2MuaWQ7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCB2ZW5kb3IgJHt2ZW5kb3JVSUR9IGZvciByZXN0YXVyYW50ICR7cmVzdGF1cmFudH1gKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBbHRlcm5hdGl2ZTogY2hlY2sgaWYgcmVzdGF1cmFudCBJRCBtYXRjaGVzIHRoZSBlYXRlcnkgSURcclxuICAgICAgICAgICAgaWYgKGVhdGVyeURhdGEuaWQgPT09IHJlc3RhdXJhbnQgfHwgZWF0ZXJ5RGF0YS5yZXN0YXVyYW50SWQgPT09IHJlc3RhdXJhbnQpIHtcclxuICAgICAgICAgICAgICB2ZW5kb3JVSUQgPSBkb2MuaWQ7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCB2ZW5kb3IgJHt2ZW5kb3JVSUR9IGZvciByZXN0YXVyYW50ICR7cmVzdGF1cmFudH0gKGRpcmVjdCBtYXRjaClgKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGxvb2t1cEVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBDb3VsZCBub3QgbG9va3VwIHZlbmRvciBmcm9tIGVhdGVyaWVzIGNvbGxlY3Rpb246JywgbG9va3VwRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBNZXRob2QgMjogSWYgbm8gc3BlY2lmaWMgbWFwcGluZyBmb3VuZCwgc2F2ZSB0byBhbGwgYWN0aXZlIHZlbmRvcnNcclxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgb3JkZXJzIGRvbid0IGdldCBsb3N0IHdoaWxlIHRoZSBtYXBwaW5nIHN5c3RlbSBpcyBiZWluZyBzZXQgdXBcclxuICAgICAgICBjb25zdCB2ZW5kb3JVSURzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh2ZW5kb3JVSUQpIHtcclxuICAgICAgICAgIHZlbmRvclVJRHMucHVzaCh2ZW5kb3JVSUQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UhCBObyBzcGVjaWZpYyB2ZW5kb3IgZm91bmQgZm9yIHJlc3RhdXJhbnQgJHtyZXN0YXVyYW50fSwgd2lsbCBzYXZlIHRvIGFsbCBhY3RpdmUgdmVuZG9yc2ApO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBHZXQgYWxsIHZlbmRvciBVSURzIGZyb20gZWF0ZXJpZXMgY29sbGVjdGlvblxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgYWxsRWF0ZXJpZXNTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MoY29sbGVjdGlvbihkYiwgJ2VhdGVyaWVzJykpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGFsbEVhdGVyaWVzU25hcHNob3QuZG9jcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgYWxsVmVuZG9yVUlEcyA9IGFsbEVhdGVyaWVzU25hcHNob3QuZG9jcy5tYXAoZG9jID0+IGRvYy5pZCk7XHJcbiAgICAgICAgICAgICAgdmVuZG9yVUlEcy5wdXNoKC4uLmFsbFZlbmRvclVJRHMpO1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OLIEZvdW5kICR7YWxsVmVuZG9yVUlEcy5sZW5ndGh9IGFjdGl2ZSB2ZW5kb3JzOmAsIGFsbFZlbmRvclVJRHMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OtIE5vIGVhdGVyaWVzIGNvbGxlY3Rpb24gZm91bmQuIENyZWF0aW5nIHZlbmRvciBlbnRyeSBmb3IgY3VycmVudCBkZW1vIHVzZXIuYCk7XHJcbiAgICAgICAgICAgICAgLy8gSWYgbm8gZWF0ZXJpZXMgZXhpc3QsIGNyZWF0ZSBvbmUgZm9yIHRoZSBkZW1vIHZlbmRvclxyXG4gICAgICAgICAgICAgIHZlbmRvclVJRHMucHVzaCgnMEdJM01valZuTGZ2elNFcU1jMjVvQ3pBbUN6MicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChhbGxWZW5kb3JzRXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gQ291bGQgbm90IGdldCBhbGwgdmVuZG9ycywgdXNpbmcgZmFsbGJhY2sgVUlEcycpO1xyXG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBrbm93biBVSURzIGlmIHRoZSBxdWVyeSBmYWlsc1xyXG4gICAgICAgICAgICB2ZW5kb3JVSURzLnB1c2goJzBHSTNNb2pWbkxmdnpTRXFNYzI1b0N6QW1DejInKTsgLy8gQ3VycmVudCBkZW1vIHZlbmRvclxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYPCfjq8gV2lsbCBzYXZlIG9yZGVyIHRvICR7dmVuZG9yVUlEcy5sZW5ndGh9IHZlbmRvcihzKTpgLCB2ZW5kb3JVSURzKTtcclxuXHJcbiAgICAgICAgLy8gU2F2ZSBvcmRlciB0byBlYWNoIHZlbmRvcidzIGNvbGxlY3Rpb25cclxuICAgICAgICBmb3IgKGNvbnN0IGN1cnJlbnRWZW5kb3JVSUQgb2YgdmVuZG9yVUlEcykge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gRmlyc3QsIGVuc3VyZSB0aGUgdmVuZG9yJ3MgZWF0ZXJ5IGRvY3VtZW50IGV4aXN0c1xyXG4gICAgICAgICAgICBjb25zdCBlYXRlcnlEb2NSZWYgPSBkb2MoZGIsICdlYXRlcmllcycsIGN1cnJlbnRWZW5kb3JVSUQpO1xyXG4gICAgICAgICAgICBhd2FpdCBzZXREb2MoZWF0ZXJ5RG9jUmVmLCB7XHJcbiAgICAgICAgICAgICAgaWQ6IGN1cnJlbnRWZW5kb3JVSUQsXHJcbiAgICAgICAgICAgICAgbmFtZTogcmVzdGF1cmFudE5hbWUgfHwgJ1Jlc3RhdXJhbnQnLCAvLyBVc2UgYWN0dWFsIHJlc3RhdXJhbnQgbmFtZVxyXG4gICAgICAgICAgICAgIGVtYWlsOiAndmVuZG9yQGNob3BjaG9wLmNvbScsXHJcbiAgICAgICAgICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcclxuICAgICAgICAgICAgICByZXN0YXVyYW50SWRzOiBbcmVzdGF1cmFudF0gLy8gTWFwIHRoaXMgdmVuZG9yIHRvIHRoaXMgcmVzdGF1cmFudFxyXG4gICAgICAgICAgICB9LCB7IG1lcmdlOiB0cnVlIH0pOyAvLyBtZXJnZTogdHJ1ZSBtZWFucyBvbmx5IHVwZGF0ZSBpZiBkb2N1bWVudCBkb2Vzbid0IGV4aXN0XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEVuc3VyZWQgZWF0ZXJ5IGRvY3VtZW50IGV4aXN0cyBmb3IgdmVuZG9yOiAke2N1cnJlbnRWZW5kb3JVSUR9YCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCB2ZW5kb3JPcmRlckRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgLy8gVXNlIHRoZSBleGFjdCBzYW1lIHN0cnVjdHVyZSB0aGF0IE1lbnVWZXJzZSBleHBlY3RzXHJcbiAgICAgICAgICAgICAgaWQ6IGRvY1JlZi5pZCxcclxuICAgICAgICAgICAgICBlYXRlcnlJZDogY3VycmVudFZlbmRvclVJRCxcclxuICAgICAgICAgICAgICBjdXN0b21lcjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogY3VzdG9tZXI/Lm5hbWUgfHwgJ0Nob3BDaG9wIEN1c3RvbWVyJyxcclxuICAgICAgICAgICAgICAgIGVtYWlsOiBjdXN0b21lcj8uZW1haWwgfHwgJ2N1c3RvbWVyQGNob3BjaG9wLmNvbScsXHJcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzPy5kZWxpdmVyeUFkZHJlc3MgfHwgY3VzdG9tZXI/LmFkZHJlc3MgfHwgJ05vIGFkZHJlc3MgcHJvdmlkZWQnXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBpdGVtczogb3JkZXJJbnB1dC5tYXAoKGl0ZW0sIGluZGV4KSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgaWQ6IGAke2RvY1JlZi5pZH0taXRlbS0ke2luZGV4fWAsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBpdGVtLnRpdGxlLFxyXG4gICAgICAgICAgICAgICAgcXVhbnRpdHk6IGl0ZW0ucXVhbnRpdHksXHJcbiAgICAgICAgICAgICAgICBwcmljZTogaXRlbS5wcmljZVxyXG4gICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICB0b3RhbEFtb3VudDogb3JkZXJBbW91bnQsXHJcbiAgICAgICAgICAgICAgc3RhdHVzOiBvcmRlclN0YXR1cyA9PT0gJ1BFTkRJTkcnID8gJ1BlbmRpbmcnIDogXHJcbiAgICAgICAgICAgICAgICAgICAgIG9yZGVyU3RhdHVzID09PSAnQ09ORklSTUVEJyA/ICdDb25maXJtZWQnIDogJ1BlbmRpbmcnLFxyXG4gICAgICAgICAgICAgIGNyZWF0ZWRBdDogZmlyZXN0b3JlT3JkZXIuY3JlYXRlZEF0LFxyXG4gICAgICAgICAgICAgIC8vIEFkZGl0aW9uYWwgQ2hvcENob3Agc3BlY2lmaWMgZmllbGRzXHJcbiAgICAgICAgICAgICAgb3JkZXJJZDogb3JkZXJDb2RlLFxyXG4gICAgICAgICAgICAgIHJlc3RhdXJhbnRJZDogcmVzdGF1cmFudCxcclxuICAgICAgICAgICAgICBwYXltZW50TWV0aG9kLFxyXG4gICAgICAgICAgICAgIHBsYXRmb3JtOiAnQ2hvcENob3AnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCB2ZW5kb3JQYXRoID0gYGVhdGVyaWVzLyR7Y3VycmVudFZlbmRvclVJRH0vb3JkZXJzYDtcclxuICAgICAgICAgICAgY29uc3QgdmVuZG9yRG9jUmVmID0gYXdhaXQgYWRkRG9jKGNvbGxlY3Rpb24oZGIsICdlYXRlcmllcycsIGN1cnJlbnRWZW5kb3JVSUQsICdvcmRlcnMnKSwgdmVuZG9yT3JkZXJEYXRhKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgT3JkZXIgJHtvcmRlckNvZGV9IHNhdmVkIHRvIHZlbmRvciBwYXRoOiAke3ZlbmRvclBhdGh9IHdpdGggSUQ6ICR7dmVuZG9yRG9jUmVmLmlkfWApO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBPcmRlciBkYXRhIHNhdmVkOmAsIHZlbmRvck9yZGVyRGF0YSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46vIFZFUklGSUNBVElPTjogT3JkZXIgc2hvdWxkIGJlIHZpc2libGUgYXQgRmlyZWJhc2UgcGF0aDogZWF0ZXJpZXMvJHtjdXJyZW50VmVuZG9yVUlEfS9vcmRlcnMvJHt2ZW5kb3JEb2NSZWYuaWR9YCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyDwn5SEIFNZTkMgVE8gQ1VTVE9NRVIgT1JERVJTOiBTYXZlIG9yZGVyIHRvIGN1c3RvbWVyLWFjY2Vzc2libGUgY29sbGVjdGlvblxyXG4gICAgICAgICAgICAvLyBUZW1wb3JhcmlseSBkaXNhYmxlZCB0byBmaXggYnVpbGQgaXNzdWVcclxuICAgICAgICAgICAgLypcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBjb25zdCBjdXN0b21lck9yZGVySWQgPSBhd2FpdCBPcmRlclN5bmNTZXJ2aWNlLnNhdmVDdXN0b21lck9yZGVyKHtcclxuICAgICAgICAgICAgICAgIG9yZGVySWQ6IG9yZGVyQ29kZSxcclxuICAgICAgICAgICAgICAgIGN1c3RvbWVySWQ6IGN1c3RvbWVyPy5lbWFpbCB8fCBgY3VzdG9tZXItJHtEYXRlLm5vdygpfWAsIC8vIFVzZSBlbWFpbCBhcyBjdXN0b21lciBJRFxyXG4gICAgICAgICAgICAgICAgdmVuZG9ySWQ6IGN1cnJlbnRWZW5kb3JVSUQsXHJcbiAgICAgICAgICAgICAgICByZXN0YXVyYW50SWQ6IHJlc3RhdXJhbnQsXHJcbiAgICAgICAgICAgICAgICByZXN0YXVyYW50TmFtZTogcmVzdGF1cmFudE5hbWUgfHwgJ1Jlc3RhdXJhbnQnLCAvLyBVc2UgYWN0dWFsIHJlc3RhdXJhbnQgbmFtZVxyXG4gICAgICAgICAgICAgICAgY3VzdG9tZXI6IHtcclxuICAgICAgICAgICAgICAgICAgbmFtZTogY3VzdG9tZXI/Lm5hbWUgfHwgJ0Nob3BDaG9wIEN1c3RvbWVyJyxcclxuICAgICAgICAgICAgICAgICAgZW1haWw6IGN1c3RvbWVyPy5lbWFpbCB8fCAnY3VzdG9tZXJAY2hvcGNob3AuY29tJyxcclxuICAgICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcz8uZGVsaXZlcnlBZGRyZXNzIHx8IGN1c3RvbWVyPy5hZGRyZXNzIHx8ICdObyBhZGRyZXNzIHByb3ZpZGVkJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGl0ZW1zOiBvcmRlcklucHV0Lm1hcCgoaXRlbSwgaW5kZXgpID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgIGlkOiBgJHtvcmRlckNvZGV9LWl0ZW0tJHtpbmRleH1gLFxyXG4gICAgICAgICAgICAgICAgICBuYW1lOiBpdGVtLnRpdGxlLFxyXG4gICAgICAgICAgICAgICAgICBxdWFudGl0eTogaXRlbS5xdWFudGl0eSxcclxuICAgICAgICAgICAgICAgICAgcHJpY2U6IGl0ZW0ucHJpY2VcclxuICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBvcmRlckFtb3VudCxcclxuICAgICAgICAgICAgICAgIHN0YXR1czogb3JkZXJTdGF0dXMgPT09ICdQRU5ESU5HJyA/ICdQZW5kaW5nJyA6IFxyXG4gICAgICAgICAgICAgICAgICAgICAgIG9yZGVyU3RhdHVzID09PSAnQ09ORklSTUVEJyA/ICdDb25maXJtZWQnIDogJ1BlbmRpbmcnLFxyXG4gICAgICAgICAgICAgICAgcGF5bWVudE1ldGhvZDogcGF5bWVudE1ldGhvZFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGlmIChjdXN0b21lck9yZGVySWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgQ3VzdG9tZXIgb3JkZXIgc3luY2VkOiBjdXN0b21lci1vcmRlcnMvJHtjdXN0b21lck9yZGVySWR9YCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChzeW5jRXJyb3IpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBGYWlsZWQgdG8gc3luYyBjdXN0b21lciBvcmRlcjonLCBzeW5jRXJyb3IpO1xyXG4gICAgICAgICAgICAgIC8vIERvbid0IGZhaWwgdGhlIG1haW4gb3JkZXIgLSB0aGlzIGlzIHN1cHBsZW1lbnRhcnlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgIH0gY2F0Y2ggKHBhdGhFcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgRmFpbGVkIHRvIHNhdmUgdG8gdmVuZG9yIFVJRCAke2N1cnJlbnRWZW5kb3JVSUR9OmAsIHBhdGhFcnJvcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJTVBPUlRBTlQ6IExldCdzIGFsc28gdHJ5IHRvIHNhdmUgdG8gYSBwcmVkaWN0YWJsZSBwYXRoIGZvciB0ZXN0aW5nXHJcbiAgICAgICAgLy8gVGhpcyB3aWxsIGhlbHAgdXMgZGVidWcgd2hhdCdzIGhhcHBlbmluZ1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBkZWJ1Z09yZGVyRGF0YSA9IHtcclxuICAgICAgICAgICAgaWQ6IGRvY1JlZi5pZCxcclxuICAgICAgICAgICAgZWF0ZXJ5SWQ6ICdERUJVR19WRU5ET1InLFxyXG4gICAgICAgICAgICBjdXN0b21lcjogeyBuYW1lOiAnRGVidWcgQ3VzdG9tZXInLCBlbWFpbDogJ2RlYnVnQHRlc3QuY29tJywgYWRkcmVzczogJ0RlYnVnIEFkZHJlc3MnIH0sXHJcbiAgICAgICAgICAgIGl0ZW1zOiBbeyBpZDogJ2RlYnVnLWl0ZW0nLCBuYW1lOiAnRGVidWcgSXRlbScsIHF1YW50aXR5OiAxLCBwcmljZTogMTAuOTkgfV0sXHJcbiAgICAgICAgICAgIHRvdGFsQW1vdW50OiAxMC45OSxcclxuICAgICAgICAgICAgc3RhdHVzOiAnUGVuZGluZycsXHJcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogZmlyZXN0b3JlT3JkZXIuY3JlYXRlZEF0LFxyXG4gICAgICAgICAgICBkZWJ1Z0luZm86IHtcclxuICAgICAgICAgICAgICBvcmlnaW5hbFJlc3RhdXJhbnRJZDogcmVzdGF1cmFudCxcclxuICAgICAgICAgICAgICBvcmRlckNvZGU6IG9yZGVyQ29kZSxcclxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgICAgICBzb3VyY2U6ICdDaG9wQ2hvcCBEZWJ1ZyBTYXZlJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBhd2FpdCBhZGREb2MoY29sbGVjdGlvbihkYiwgJ2VhdGVyaWVzJywgJ0RFQlVHX1ZFTkRPUicsICdvcmRlcnMnKSwgZGVidWdPcmRlckRhdGEpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYPCfkJsgREVCVUc6IE9yZGVyIHNhdmVkIHRvIGVhdGVyaWVzL0RFQlVHX1ZFTkRPUi9vcmRlcnMgZm9yIHRlc3RpbmdgKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgIH0gY2F0Y2ggKGRlYnVnRXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybignRGVidWcgc2F2ZSBmYWlsZWQ6JywgZGVidWdFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICB9IGNhdGNoICh2ZW5kb3JFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KaoO+4jyBGYWlsZWQgdG8gc2F2ZSB0byB2ZW5kb3IgY29sbGVjdGlvbnM6JywgdmVuZG9yRXJyb3IpO1xyXG4gICAgICAgIC8vIERvbid0IHRocm93IC0gZ2xvYmFsIG9yZGVyIHdhcyBzYXZlZCBzdWNjZXNzZnVsbHlcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBvcmRlcklkOiBvcmRlckNvZGUsXHJcbiAgICAgICAgb3JkZXJTdGF0dXMsXHJcbiAgICAgICAgdG90YWw6IG9yZGVyQW1vdW50LFxyXG4gICAgICAgIGZpcmViYXNlSWQ6IGRvY1JlZi5pZFxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGaXJlYmFzZSBvcmRlciBjcmVhdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwbGFjZSBvcmRlcjogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIGFzeW5jIHVwZGF0ZU9yZGVyU3RhdHVzKGZpcmViYXNlSWQ6IHN0cmluZywgc3RhdHVzOiBzdHJpbmcsIHBhaWRBbW91bnQ/OiBudW1iZXIpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgdXBkYXRlRG9jLCBkb2MgfSA9IGF3YWl0IGltcG9ydCgnZmlyZWJhc2UvZmlyZXN0b3JlJyk7XHJcbiAgICAgIGNvbnN0IG9yZGVyUmVmID0gZG9jKGRiLCAnb3JkZXJzJywgZmlyZWJhc2VJZCk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB1cGRhdGVEYXRhOiBhbnkgPSB7XHJcbiAgICAgICAgb3JkZXJTdGF0dXM6IHN0YXR1cyxcclxuICAgICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpXHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICBpZiAocGFpZEFtb3VudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdXBkYXRlRGF0YS5wYWlkQW1vdW50ID0gcGFpZEFtb3VudDtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgYXdhaXQgdXBkYXRlRG9jKG9yZGVyUmVmLCB1cGRhdGVEYXRhKTtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBPcmRlciAke2ZpcmViYXNlSWR9IHN0YXR1cyB1cGRhdGVkIHRvICR7c3RhdHVzfWApO1xyXG4gICAgICBcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGaXJlYmFzZSBvcmRlciB1cGRhdGUgZmFpbGVkOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBPcmRlclNlcnZpY2U7Il0sIm5hbWVzIjpbImdldEZpcmVzdG9yZSIsImNvbGxlY3Rpb24iLCJhZGREb2MiLCJzZXJ2ZXJUaW1lc3RhbXAiLCJnZXREb2NzIiwiZG9jIiwic2V0RG9jIiwiZ2V0RmlyZWJhc2VBcHAiLCJkYiIsIk9yZGVyU2VydmljZSIsInBsYWNlT3JkZXIiLCJyZXN0YXVyYW50IiwicmVzdGF1cmFudE5hbWUiLCJvcmRlcklucHV0IiwicGF5bWVudE1ldGhvZCIsImFkZHJlc3MiLCJjdXN0b21lciIsImRlbGl2ZXJ5Q2hhcmdlcyIsInRpcHBpbmciLCJ0YXhhdGlvbkFtb3VudCIsImluc3RydWN0aW9ucyIsImlzUGlja2VkVXAiLCJzdWJ0b3RhbCIsInJlZHVjZSIsInN1bSIsIml0ZW0iLCJwcmljZSIsInF1YW50aXR5Iiwib3JkZXJBbW91bnQiLCJvcmRlclN0YXR1cyIsInBhaWRBbW91bnQiLCJvcmRlckNvZGUiLCJEYXRlIiwibm93IiwiZmlyZXN0b3JlT3JkZXIiLCJvcmRlcklkIiwicmVzdGF1cmFudElkIiwib3JkZXJEYXRlIiwidG9JU09TdHJpbmciLCJjcmVhdGVkQXQiLCJpdGVtcyIsInZlbmRvck5vdGlmaWVkIiwib3JkZXJUeXBlIiwicGxhdGZvcm0iLCJkZWxpdmVyeUFkZHJlc3MiLCJsYXRpdHVkZSIsInVuZGVmaW5lZCIsImRlbGl2ZXJ5TGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJkZWxpdmVyeUxvbmdpdHVkZSIsImRvY1JlZiIsImNvbnNvbGUiLCJsb2ciLCJpZCIsInZlbmRvclVJRCIsImVhdGVyaWVzU25hcHNob3QiLCJkb2NzIiwiZWF0ZXJ5RGF0YSIsImRhdGEiLCJyZXN0YXVyYW50SWRzIiwiaW5jbHVkZXMiLCJsb29rdXBFcnJvciIsIndhcm4iLCJ2ZW5kb3JVSURzIiwicHVzaCIsImFsbEVhdGVyaWVzU25hcHNob3QiLCJsZW5ndGgiLCJhbGxWZW5kb3JVSURzIiwibWFwIiwiYWxsVmVuZG9yc0Vycm9yIiwiY3VycmVudFZlbmRvclVJRCIsImVhdGVyeURvY1JlZiIsIm5hbWUiLCJlbWFpbCIsIm1lcmdlIiwidmVuZG9yT3JkZXJEYXRhIiwiZWF0ZXJ5SWQiLCJpbmRleCIsInRpdGxlIiwidG90YWxBbW91bnQiLCJzdGF0dXMiLCJ2ZW5kb3JQYXRoIiwidmVuZG9yRG9jUmVmIiwicGF0aEVycm9yIiwiZXJyb3IiLCJkZWJ1Z09yZGVyRGF0YSIsImRlYnVnSW5mbyIsIm9yaWdpbmFsUmVzdGF1cmFudElkIiwidGltZXN0YW1wIiwic291cmNlIiwiZGVidWdFcnJvciIsInZlbmRvckVycm9yIiwidG90YWwiLCJmaXJlYmFzZUlkIiwiRXJyb3IiLCJtZXNzYWdlIiwidXBkYXRlT3JkZXJTdGF0dXMiLCJ1cGRhdGVEb2MiLCJvcmRlclJlZiIsInVwZGF0ZURhdGEiLCJ1cGRhdGVkQXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/firebase/orders.ts\n"));

/***/ })

});