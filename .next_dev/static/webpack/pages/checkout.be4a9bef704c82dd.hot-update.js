"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/checkout",{

/***/ "./lib/firebase/orders.ts":
/*!********************************!*\
  !*** ./lib/firebase/orders.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrderService: function() { return /* binding */ OrderService; }\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client */ \"./lib/firebase/client.ts\");\n\n\n// // import { OrderSyncService } from './order-sync'; // Temporarily disabled to fix build // Temporarily disabled to fix build\n// Initialize Firestore\nconst db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getFirestore)((0,_client__WEBPACK_IMPORTED_MODULE_1__.getFirebaseApp)());\nclass OrderService {\n    static async placeOrder(param) {\n        let { restaurant, restaurantName, orderInput, paymentMethod, address, customer, deliveryCharges = 0, tipping = 0, taxationAmount = 0, instructions = \"\", isPickedUp = false } = param;\n        try {\n            // Calculate order details\n            const subtotal = orderInput.reduce((sum, item)=>sum + item.price * item.quantity, 0);\n            const orderAmount = subtotal + deliveryCharges + tipping + taxationAmount;\n            // Determine order status based on payment method\n            let orderStatus = \"PENDING\";\n            let paidAmount = 0;\n            if (paymentMethod === \"CASH\") {\n                orderStatus = \"PENDING\"; // Will be paid on delivery\n                paidAmount = 0;\n            } else if (paymentMethod === \"CARD\" || paymentMethod === \"WALLET\") {\n                orderStatus = \"CONFIRMED\"; // Electronic payments - assume paid immediately\n                paidAmount = orderAmount;\n            } else if (paymentMethod === \"BANK\") {\n                orderStatus = \"PAYMENT_PENDING\"; // Bank transfer - awaiting verification\n                paidAmount = 0;\n            }\n            const orderCode = \"CC\".concat(Date.now());\n            // Create Firebase order object (removing undefined values)\n            const firestoreOrder = {\n                orderId: orderCode,\n                restaurantId: restaurant,\n                orderStatus,\n                paymentMethod,\n                orderAmount,\n                paidAmount,\n                deliveryCharges,\n                tipping,\n                taxationAmount,\n                orderDate: new Date().toISOString(),\n                isPickedUp,\n                createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                items: orderInput,\n                // Vendor notification fields for MenuVerse integration\n                vendorNotified: false,\n                orderType: \"delivery\",\n                platform: \"ChopChop\"\n            };\n            // Only add optional fields if they have values\n            if (address === null || address === void 0 ? void 0 : address.deliveryAddress) {\n                firestoreOrder.deliveryAddress = address.deliveryAddress;\n            }\n            if ((address === null || address === void 0 ? void 0 : address.latitude) !== undefined) {\n                firestoreOrder.deliveryLatitude = address.latitude;\n            }\n            if ((address === null || address === void 0 ? void 0 : address.longitude) !== undefined) {\n                firestoreOrder.deliveryLongitude = address.longitude;\n            }\n            if (instructions) {\n                firestoreOrder.instructions = instructions;\n            }\n            // Save to Firebase orders collection\n            const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"orders\"), firestoreOrder);\n            console.log(\"‚úÖ Order \".concat(orderCode, \" saved to Firebase with ID:\"), docRef.id);\n            // ALSO save to vendor-specific collection for MenuVerse notifications\n            console.log(\"\\uD83D\\uDE80 STARTING vendor save process for order \".concat(orderCode, \"...\"));\n            try {\n                // Dynamic restaurant-to-vendor mapping\n                // In production, this would come from a database lookup\n                // For now, we'll try to find the vendor UID dynamically\n                console.log(\"\\uD83D\\uDD0D Looking up vendor for restaurant ID: \".concat(restaurant));\n                // Method 1: Try to find vendor by querying the eateries collection\n                let vendorUID = null;\n                try {\n                    // Query the eateries collection to find which vendor owns this restaurant\n                    const eateriesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"eateries\"));\n                    for (const doc of eateriesSnapshot.docs){\n                        const eateryData = doc.data();\n                        // Check if this eatery has this restaurant ID\n                        // This assumes the eatery document has a restaurantIds array or similar\n                        if (eateryData.restaurantIds && eateryData.restaurantIds.includes(restaurant)) {\n                            vendorUID = doc.id;\n                            console.log(\"‚úÖ Found vendor \".concat(vendorUID, \" for restaurant \").concat(restaurant));\n                            break;\n                        }\n                        // Alternative: check if restaurant ID matches the eatery ID\n                        if (eateryData.id === restaurant || eateryData.restaurantId === restaurant) {\n                            vendorUID = doc.id;\n                            console.log(\"‚úÖ Found vendor \".concat(vendorUID, \" for restaurant \").concat(restaurant, \" (direct match)\"));\n                            break;\n                        }\n                    }\n                } catch (lookupError) {\n                    console.warn(\"‚ö†Ô∏è Could not lookup vendor from eateries collection:\", lookupError);\n                }\n                // Method 2: If no specific mapping found, save to all active vendors\n                // This ensures orders don't get lost while the mapping system is being set up\n                const vendorUIDs = [];\n                if (vendorUID) {\n                    vendorUIDs.push(vendorUID);\n                } else {\n                    console.log(\"\\uD83D\\uDD04 No specific vendor found for restaurant \".concat(restaurant, \", will save to all active vendors\"));\n                    // Get all vendor UIDs from eateries collection\n                    try {\n                        const allEateriesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"eateries\"));\n                        if (allEateriesSnapshot.docs.length > 0) {\n                            const allVendorUIDs = allEateriesSnapshot.docs.map((doc)=>doc.id);\n                            vendorUIDs.push(...allVendorUIDs);\n                            console.log(\"\\uD83D\\uDCCB Found \".concat(allVendorUIDs.length, \" active vendors:\"), allVendorUIDs);\n                        } else {\n                            console.log(\"\\uD83D\\uDCED No eateries collection found. Creating vendor entry for current demo user.\");\n                            // If no eateries exist, create one for the demo vendor\n                            vendorUIDs.push(\"0GI3MojVnLfvzSEqMc25oCzAmCz2\");\n                        }\n                    } catch (allVendorsError) {\n                        console.warn(\"‚ö†Ô∏è Could not get all vendors, using fallback UIDs\");\n                        // Fallback to known UIDs if the query fails\n                        vendorUIDs.push(\"0GI3MojVnLfvzSEqMc25oCzAmCz2\"); // Current demo vendor\n                    }\n                }\n                console.log(\"\\uD83C\\uDFAF Will save order to \".concat(vendorUIDs.length, \" vendor(s):\"), vendorUIDs);\n                // Save order to each vendor's collection\n                for (const currentVendorUID of vendorUIDs){\n                    try {\n                        // First, ensure the vendor's eatery document exists\n                        const eateryDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(db, \"eateries\", currentVendorUID);\n                        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)(eateryDocRef, {\n                            id: currentVendorUID,\n                            name: restaurantName || \"Restaurant\",\n                            email: \"vendor@chopchop.com\",\n                            createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                            restaurantIds: [\n                                restaurant\n                            ] // Map this vendor to this restaurant\n                        }, {\n                            merge: true\n                        }); // merge: true means only update if document doesn't exist\n                        console.log(\"‚úÖ Ensured eatery document exists for vendor: \".concat(currentVendorUID));\n                        const vendorOrderData = {\n                            // Use the exact same structure that MenuVerse expects\n                            id: docRef.id,\n                            eateryId: currentVendorUID,\n                            customer: {\n                                name: (customer === null || customer === void 0 ? void 0 : customer.name) || \"ChopChop Customer\",\n                                email: (customer === null || customer === void 0 ? void 0 : customer.email) || \"customer@chopchop.com\",\n                                address: (address === null || address === void 0 ? void 0 : address.deliveryAddress) || (customer === null || customer === void 0 ? void 0 : customer.address) || \"No address provided\"\n                            },\n                            items: orderInput.map((item, index)=>({\n                                    id: \"\".concat(docRef.id, \"-item-\").concat(index),\n                                    name: item.title,\n                                    quantity: item.quantity,\n                                    price: item.price\n                                })),\n                            totalAmount: orderAmount,\n                            status: orderStatus === \"PENDING\" ? \"Pending\" : orderStatus === \"CONFIRMED\" ? \"Confirmed\" : \"Pending\",\n                            createdAt: firestoreOrder.createdAt,\n                            // Additional ChopChop specific fields\n                            orderId: orderCode,\n                            restaurantId: restaurant,\n                            paymentMethod,\n                            platform: \"ChopChop\"\n                        };\n                        const vendorPath = \"eateries/\".concat(currentVendorUID, \"/orders\");\n                        const vendorDocRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"eateries\", currentVendorUID, \"orders\"), vendorOrderData);\n                        console.log(\"‚úÖ Order \".concat(orderCode, \" saved to vendor path: \").concat(vendorPath, \" with ID: \").concat(vendorDocRef.id));\n                        console.log(\"\\uD83D\\uDCCA Order data saved:\", vendorOrderData);\n                        console.log(\"\\uD83C\\uDFAF VERIFICATION: Order should be visible at Firebase path: eateries/\".concat(currentVendorUID, \"/orders/\").concat(vendorDocRef.id));\n                        // üîÑ SYNC TO CUSTOMER ORDERS: Save order to customer-accessible collection\n                        try {\n                            const customerOrderId = await OrderSyncService.saveCustomerOrder({\n                                orderId: orderCode,\n                                customerId: userId || (customer === null || customer === void 0 ? void 0 : customer.email) || \"customer-\".concat(Date.now()),\n                                vendorId: currentVendorUID,\n                                restaurantId: restaurant,\n                                restaurantName: restaurantName || \"Restaurant\",\n                                customer: {\n                                    name: (customer === null || customer === void 0 ? void 0 : customer.name) || \"ChopChop Customer\",\n                                    email: (customer === null || customer === void 0 ? void 0 : customer.email) || \"customer@chopchop.com\",\n                                    address: (address === null || address === void 0 ? void 0 : address.deliveryAddress) || (customer === null || customer === void 0 ? void 0 : customer.address) || \"No address provided\"\n                                },\n                                items: orderInput.map((item, index)=>({\n                                        id: \"\".concat(orderCode, \"-item-\").concat(index),\n                                        name: item.title,\n                                        quantity: item.quantity,\n                                        price: item.price\n                                    })),\n                                totalAmount: orderAmount,\n                                status: orderStatus === \"PENDING\" ? \"Pending\" : orderStatus === \"CONFIRMED\" ? \"Confirmed\" : \"Pending\",\n                                paymentMethod: paymentMethod\n                            });\n                            if (customerOrderId) {\n                                console.log(\"‚úÖ Customer order synced: customer-orders/\".concat(customerOrderId));\n                            }\n                        } catch (syncError) {\n                            console.warn(\"‚ö†Ô∏è Failed to sync customer order:\", syncError);\n                        // Don't fail the main order - this is supplementary\n                        }\n                    } catch (pathError) {\n                        console.error(\"‚ùå Failed to save to vendor UID \".concat(currentVendorUID, \":\"), pathError);\n                    }\n                }\n                // IMPORTANT: Let's also try to save to a predictable path for testing\n                // This will help us debug what's happening\n                try {\n                    const debugOrderData = {\n                        id: docRef.id,\n                        eateryId: \"DEBUG_VENDOR\",\n                        customer: {\n                            name: \"Debug Customer\",\n                            email: \"debug@test.com\",\n                            address: \"Debug Address\"\n                        },\n                        items: [\n                            {\n                                id: \"debug-item\",\n                                name: \"Debug Item\",\n                                quantity: 1,\n                                price: 10.99\n                            }\n                        ],\n                        totalAmount: 10.99,\n                        status: \"Pending\",\n                        createdAt: firestoreOrder.createdAt,\n                        debugInfo: {\n                            originalRestaurantId: restaurant,\n                            orderCode: orderCode,\n                            timestamp: new Date().toISOString(),\n                            source: \"ChopChop Debug Save\"\n                        }\n                    };\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"eateries\", \"DEBUG_VENDOR\", \"orders\"), debugOrderData);\n                    console.log(\"\\uD83D\\uDC1B DEBUG: Order saved to eateries/DEBUG_VENDOR/orders for testing\");\n                } catch (debugError) {\n                    console.warn(\"Debug save failed:\", debugError);\n                }\n            } catch (vendorError) {\n                console.error(\"‚ö†Ô∏è Failed to save to vendor collections:\", vendorError);\n            // Don't throw - global order was saved successfully\n            }\n            return {\n                orderId: orderCode,\n                orderStatus,\n                total: orderAmount,\n                firebaseId: docRef.id\n            };\n        } catch (error) {\n            console.error(\"‚ùå Firebase order creation failed:\", error);\n            throw new Error(\"Failed to place order: \".concat(error.message));\n        }\n    }\n    static async updateOrderStatus(firebaseId, status, paidAmount) {\n        try {\n            const { updateDoc, doc } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! firebase/firestore */ \"./node_modules/firebase/firestore/dist/esm/index.esm.js\"));\n            const orderRef = doc(db, \"orders\", firebaseId);\n            const updateData = {\n                orderStatus: status,\n                updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n            };\n            if (paidAmount !== undefined) {\n                updateData.paidAmount = paidAmount;\n            }\n            await updateDoc(orderRef, updateData);\n            console.log(\"‚úÖ Order \".concat(firebaseId, \" status updated to \").concat(status));\n        } catch (error) {\n            console.error(\"‚ùå Firebase order update failed:\", error);\n            throw error;\n        }\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (OrderService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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NEQsV0FBVzVFLFVBQVUsR0FBR0E7WUFDMUI7WUFFQSxNQUFNMEUsVUFBVUMsVUFBVUM7WUFDMUJ2RCxRQUFRQyxHQUFHLENBQUMsV0FBMkM0QixPQUFoQ29CLFlBQVcsdUJBQTRCLE9BQVBwQjtRQUV6RCxFQUFFLE9BQU9XLE9BQU87WUFDZHhDLFFBQVF3QyxLQUFLLENBQUMsbUNBQW1DQTtZQUNqRCxNQUFNQTtRQUNSO0lBQ0Y7QUFDRjtBQUVBLCtEQUFlbEYsWUFBWUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvZmlyZWJhc2Uvb3JkZXJzLnRzPzA5NGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0RmlyZXN0b3JlLCBjb2xsZWN0aW9uLCBhZGREb2MsIHNlcnZlclRpbWVzdGFtcCwgZ2V0RG9jcywgZG9jLCBzZXREb2MgfSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xyXG5pbXBvcnQgeyBnZXRGaXJlYmFzZUFwcCB9IGZyb20gJy4vY2xpZW50JztcclxuLy8gLy8gaW1wb3J0IHsgT3JkZXJTeW5jU2VydmljZSB9IGZyb20gJy4vb3JkZXItc3luYyc7IC8vIFRlbXBvcmFyaWx5IGRpc2FibGVkIHRvIGZpeCBidWlsZCAvLyBUZW1wb3JhcmlseSBkaXNhYmxlZCB0byBmaXggYnVpbGRcclxuXHJcbi8vIEluaXRpYWxpemUgRmlyZXN0b3JlXHJcbmNvbnN0IGRiID0gZ2V0RmlyZXN0b3JlKGdldEZpcmViYXNlQXBwKCkpO1xyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPcmRlckl0ZW0ge1xyXG4gIHRpdGxlOiBzdHJpbmc7XHJcbiAgcXVhbnRpdHk6IG51bWJlcjtcclxuICBwcmljZTogbnVtYmVyO1xyXG4gIHZhcmlhdGlvbj86IHN0cmluZztcclxuICBhZGRvbnM/OiBzdHJpbmc7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgT3JkZXJBZGRyZXNzIHtcclxuICBkZWxpdmVyeUFkZHJlc3M6IHN0cmluZztcclxuICBsYXRpdHVkZT86IG51bWJlcjtcclxuICBsb25naXR1ZGU/OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgRmlyZWJhc2VPcmRlciB7XHJcbiAgb3JkZXJJZDogc3RyaW5nO1xyXG4gIHJlc3RhdXJhbnRJZDogbnVtYmVyO1xyXG4gIG9yZGVyU3RhdHVzOiBzdHJpbmc7XHJcbiAgcGF5bWVudE1ldGhvZDogc3RyaW5nO1xyXG4gIG9yZGVyQW1vdW50OiBudW1iZXI7XHJcbiAgcGFpZEFtb3VudDogbnVtYmVyO1xyXG4gIGRlbGl2ZXJ5QWRkcmVzcz86IHN0cmluZztcclxuICBkZWxpdmVyeUxhdGl0dWRlPzogbnVtYmVyO1xyXG4gIGRlbGl2ZXJ5TG9uZ2l0dWRlPzogbnVtYmVyO1xyXG4gIGluc3RydWN0aW9ucz86IHN0cmluZztcclxuICBkZWxpdmVyeUNoYXJnZXM6IG51bWJlcjtcclxuICB0aXBwaW5nOiBudW1iZXI7XHJcbiAgdGF4YXRpb25BbW91bnQ6IG51bWJlcjtcclxuICBvcmRlckRhdGU6IHN0cmluZztcclxuICBpc1BpY2tlZFVwOiBib29sZWFuO1xyXG4gIGNyZWF0ZWRBdDogYW55OyAvLyBzZXJ2ZXJUaW1lc3RhbXBcclxuICBpdGVtczogT3JkZXJJdGVtW107XHJcbiAgdmVuZG9yTm90aWZpZWQ6IGJvb2xlYW47XHJcbiAgb3JkZXJUeXBlOiBzdHJpbmc7XHJcbiAgcGxhdGZvcm06IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE9yZGVyU2VydmljZSB7XHJcbiAgc3RhdGljIGFzeW5jIHBsYWNlT3JkZXIoe1xyXG4gICAgcmVzdGF1cmFudCxcclxuICAgIHJlc3RhdXJhbnROYW1lLFxyXG4gICAgb3JkZXJJbnB1dCxcclxuICAgIHBheW1lbnRNZXRob2QsXHJcbiAgICBhZGRyZXNzLFxyXG4gICAgY3VzdG9tZXIsXHJcbiAgICBkZWxpdmVyeUNoYXJnZXMgPSAwLFxyXG4gICAgdGlwcGluZyA9IDAsXHJcbiAgICB0YXhhdGlvbkFtb3VudCA9IDAsXHJcbiAgICBpbnN0cnVjdGlvbnMgPSAnJyxcclxuICAgIGlzUGlja2VkVXAgPSBmYWxzZVxyXG4gIH06IHtcclxuICAgIHJlc3RhdXJhbnQ6IG51bWJlcjtcclxuICAgIHJlc3RhdXJhbnROYW1lPzogc3RyaW5nO1xyXG4gICAgb3JkZXJJbnB1dDogT3JkZXJJdGVtW107XHJcbiAgICBwYXltZW50TWV0aG9kOiBzdHJpbmc7XHJcbiAgICBhZGRyZXNzPzogT3JkZXJBZGRyZXNzO1xyXG4gICAgY3VzdG9tZXI/OiB7XHJcbiAgICAgIG5hbWU6IHN0cmluZztcclxuICAgICAgZW1haWw6IHN0cmluZztcclxuICAgICAgYWRkcmVzcz86IHN0cmluZztcclxuICAgIH07XHJcbiAgICBkZWxpdmVyeUNoYXJnZXM/OiBudW1iZXI7XHJcbiAgICB0aXBwaW5nPzogbnVtYmVyO1xyXG4gICAgdGF4YXRpb25BbW91bnQ/OiBudW1iZXI7XHJcbiAgICBpbnN0cnVjdGlvbnM/OiBzdHJpbmc7XHJcbiAgICBpc1BpY2tlZFVwPzogYm9vbGVhbjtcclxuICB9KSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBDYWxjdWxhdGUgb3JkZXIgZGV0YWlsc1xyXG4gICAgICBjb25zdCBzdWJ0b3RhbCA9IG9yZGVySW5wdXQucmVkdWNlKChzdW0sIGl0ZW0pID0+IHN1bSArIChpdGVtLnByaWNlICogaXRlbS5xdWFudGl0eSksIDApO1xyXG4gICAgICBjb25zdCBvcmRlckFtb3VudCA9IHN1YnRvdGFsICsgZGVsaXZlcnlDaGFyZ2VzICsgdGlwcGluZyArIHRheGF0aW9uQW1vdW50O1xyXG4gICAgICBcclxuICAgICAgLy8gRGV0ZXJtaW5lIG9yZGVyIHN0YXR1cyBiYXNlZCBvbiBwYXltZW50IG1ldGhvZFxyXG4gICAgICBsZXQgb3JkZXJTdGF0dXMgPSAnUEVORElORyc7XHJcbiAgICAgIGxldCBwYWlkQW1vdW50ID0gMDtcclxuICAgICAgXHJcbiAgICAgIGlmIChwYXltZW50TWV0aG9kID09PSAnQ0FTSCcpIHtcclxuICAgICAgICBvcmRlclN0YXR1cyA9ICdQRU5ESU5HJzsgLy8gV2lsbCBiZSBwYWlkIG9uIGRlbGl2ZXJ5XHJcbiAgICAgICAgcGFpZEFtb3VudCA9IDA7XHJcbiAgICAgIH0gZWxzZSBpZiAocGF5bWVudE1ldGhvZCA9PT0gJ0NBUkQnIHx8IHBheW1lbnRNZXRob2QgPT09ICdXQUxMRVQnKSB7XHJcbiAgICAgICAgb3JkZXJTdGF0dXMgPSAnQ09ORklSTUVEJzsgLy8gRWxlY3Ryb25pYyBwYXltZW50cyAtIGFzc3VtZSBwYWlkIGltbWVkaWF0ZWx5XHJcbiAgICAgICAgcGFpZEFtb3VudCA9IG9yZGVyQW1vdW50O1xyXG4gICAgICB9IGVsc2UgaWYgKHBheW1lbnRNZXRob2QgPT09ICdCQU5LJykge1xyXG4gICAgICAgIG9yZGVyU3RhdHVzID0gJ1BBWU1FTlRfUEVORElORyc7IC8vIEJhbmsgdHJhbnNmZXIgLSBhd2FpdGluZyB2ZXJpZmljYXRpb25cclxuICAgICAgICBwYWlkQW1vdW50ID0gMDtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3Qgb3JkZXJDb2RlID0gYENDJHtEYXRlLm5vdygpfWA7XHJcbiAgICAgIFxyXG4gICAgICAvLyBDcmVhdGUgRmlyZWJhc2Ugb3JkZXIgb2JqZWN0IChyZW1vdmluZyB1bmRlZmluZWQgdmFsdWVzKVxyXG4gICAgICBjb25zdCBmaXJlc3RvcmVPcmRlcjogYW55ID0ge1xyXG4gICAgICAgIG9yZGVySWQ6IG9yZGVyQ29kZSxcclxuICAgICAgICByZXN0YXVyYW50SWQ6IHJlc3RhdXJhbnQsXHJcbiAgICAgICAgb3JkZXJTdGF0dXMsXHJcbiAgICAgICAgcGF5bWVudE1ldGhvZCxcclxuICAgICAgICBvcmRlckFtb3VudCxcclxuICAgICAgICBwYWlkQW1vdW50LFxyXG4gICAgICAgIGRlbGl2ZXJ5Q2hhcmdlcyxcclxuICAgICAgICB0aXBwaW5nLFxyXG4gICAgICAgIHRheGF0aW9uQW1vdW50LFxyXG4gICAgICAgIG9yZGVyRGF0ZTogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgIGlzUGlja2VkVXAsXHJcbiAgICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcclxuICAgICAgICBpdGVtczogb3JkZXJJbnB1dCxcclxuICAgICAgICAvLyBWZW5kb3Igbm90aWZpY2F0aW9uIGZpZWxkcyBmb3IgTWVudVZlcnNlIGludGVncmF0aW9uXHJcbiAgICAgICAgdmVuZG9yTm90aWZpZWQ6IGZhbHNlLFxyXG4gICAgICAgIG9yZGVyVHlwZTogJ2RlbGl2ZXJ5JyxcclxuICAgICAgICBwbGF0Zm9ybTogJ0Nob3BDaG9wJ1xyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gT25seSBhZGQgb3B0aW9uYWwgZmllbGRzIGlmIHRoZXkgaGF2ZSB2YWx1ZXNcclxuICAgICAgaWYgKGFkZHJlc3M/LmRlbGl2ZXJ5QWRkcmVzcykge1xyXG4gICAgICAgIGZpcmVzdG9yZU9yZGVyLmRlbGl2ZXJ5QWRkcmVzcyA9IGFkZHJlc3MuZGVsaXZlcnlBZGRyZXNzO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhZGRyZXNzPy5sYXRpdHVkZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZmlyZXN0b3JlT3JkZXIuZGVsaXZlcnlMYXRpdHVkZSA9IGFkZHJlc3MubGF0aXR1ZGU7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGFkZHJlc3M/LmxvbmdpdHVkZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgZmlyZXN0b3JlT3JkZXIuZGVsaXZlcnlMb25naXR1ZGUgPSBhZGRyZXNzLmxvbmdpdHVkZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaW5zdHJ1Y3Rpb25zKSB7XHJcbiAgICAgICAgZmlyZXN0b3JlT3JkZXIuaW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBTYXZlIHRvIEZpcmViYXNlIG9yZGVycyBjb2xsZWN0aW9uXHJcbiAgICAgIGNvbnN0IGRvY1JlZiA9IGF3YWl0IGFkZERvYyhjb2xsZWN0aW9uKGRiLCAnb3JkZXJzJyksIGZpcmVzdG9yZU9yZGVyKTtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBPcmRlciAke29yZGVyQ29kZX0gc2F2ZWQgdG8gRmlyZWJhc2Ugd2l0aCBJRDpgLCBkb2NSZWYuaWQpO1xyXG5cclxuICAgICAgLy8gQUxTTyBzYXZlIHRvIHZlbmRvci1zcGVjaWZpYyBjb2xsZWN0aW9uIGZvciBNZW51VmVyc2Ugbm90aWZpY2F0aW9uc1xyXG4gICAgICBjb25zb2xlLmxvZyhg8J+agCBTVEFSVElORyB2ZW5kb3Igc2F2ZSBwcm9jZXNzIGZvciBvcmRlciAke29yZGVyQ29kZX0uLi5gKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyBEeW5hbWljIHJlc3RhdXJhbnQtdG8tdmVuZG9yIG1hcHBpbmdcclxuICAgICAgICAvLyBJbiBwcm9kdWN0aW9uLCB0aGlzIHdvdWxkIGNvbWUgZnJvbSBhIGRhdGFiYXNlIGxvb2t1cFxyXG4gICAgICAgIC8vIEZvciBub3csIHdlJ2xsIHRyeSB0byBmaW5kIHRoZSB2ZW5kb3IgVUlEIGR5bmFtaWNhbGx5XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coYPCflI0gTG9va2luZyB1cCB2ZW5kb3IgZm9yIHJlc3RhdXJhbnQgSUQ6ICR7cmVzdGF1cmFudH1gKTtcclxuICAgICAgICBcclxuICAgICAgICAvLyBNZXRob2QgMTogVHJ5IHRvIGZpbmQgdmVuZG9yIGJ5IHF1ZXJ5aW5nIHRoZSBlYXRlcmllcyBjb2xsZWN0aW9uXHJcbiAgICAgICAgbGV0IHZlbmRvclVJRDogc3RyaW5nIHwgbnVsbCA9IG51bGw7XHJcbiAgICAgICAgXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIC8vIFF1ZXJ5IHRoZSBlYXRlcmllcyBjb2xsZWN0aW9uIHRvIGZpbmQgd2hpY2ggdmVuZG9yIG93bnMgdGhpcyByZXN0YXVyYW50XHJcbiAgICAgICAgICBjb25zdCBlYXRlcmllc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhjb2xsZWN0aW9uKGRiLCAnZWF0ZXJpZXMnKSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGZvciAoY29uc3QgZG9jIG9mIGVhdGVyaWVzU25hcHNob3QuZG9jcykge1xyXG4gICAgICAgICAgICBjb25zdCBlYXRlcnlEYXRhID0gZG9jLmRhdGEoKTtcclxuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBlYXRlcnkgaGFzIHRoaXMgcmVzdGF1cmFudCBJRFxyXG4gICAgICAgICAgICAvLyBUaGlzIGFzc3VtZXMgdGhlIGVhdGVyeSBkb2N1bWVudCBoYXMgYSByZXN0YXVyYW50SWRzIGFycmF5IG9yIHNpbWlsYXJcclxuICAgICAgICAgICAgaWYgKGVhdGVyeURhdGEucmVzdGF1cmFudElkcyAmJiBlYXRlcnlEYXRhLnJlc3RhdXJhbnRJZHMuaW5jbHVkZXMocmVzdGF1cmFudCkpIHtcclxuICAgICAgICAgICAgICB2ZW5kb3JVSUQgPSBkb2MuaWQ7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCB2ZW5kb3IgJHt2ZW5kb3JVSUR9IGZvciByZXN0YXVyYW50ICR7cmVzdGF1cmFudH1gKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBbHRlcm5hdGl2ZTogY2hlY2sgaWYgcmVzdGF1cmFudCBJRCBtYXRjaGVzIHRoZSBlYXRlcnkgSURcclxuICAgICAgICAgICAgaWYgKGVhdGVyeURhdGEuaWQgPT09IHJlc3RhdXJhbnQgfHwgZWF0ZXJ5RGF0YS5yZXN0YXVyYW50SWQgPT09IHJlc3RhdXJhbnQpIHtcclxuICAgICAgICAgICAgICB2ZW5kb3JVSUQgPSBkb2MuaWQ7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBGb3VuZCB2ZW5kb3IgJHt2ZW5kb3JVSUR9IGZvciByZXN0YXVyYW50ICR7cmVzdGF1cmFudH0gKGRpcmVjdCBtYXRjaClgKTtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2ggKGxvb2t1cEVycm9yKSB7XHJcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBDb3VsZCBub3QgbG9va3VwIHZlbmRvciBmcm9tIGVhdGVyaWVzIGNvbGxlY3Rpb246JywgbG9va3VwRXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBNZXRob2QgMjogSWYgbm8gc3BlY2lmaWMgbWFwcGluZyBmb3VuZCwgc2F2ZSB0byBhbGwgYWN0aXZlIHZlbmRvcnNcclxuICAgICAgICAvLyBUaGlzIGVuc3VyZXMgb3JkZXJzIGRvbid0IGdldCBsb3N0IHdoaWxlIHRoZSBtYXBwaW5nIHN5c3RlbSBpcyBiZWluZyBzZXQgdXBcclxuICAgICAgICBjb25zdCB2ZW5kb3JVSURzOiBzdHJpbmdbXSA9IFtdO1xyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh2ZW5kb3JVSUQpIHtcclxuICAgICAgICAgIHZlbmRvclVJRHMucHVzaCh2ZW5kb3JVSUQpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+UhCBObyBzcGVjaWZpYyB2ZW5kb3IgZm91bmQgZm9yIHJlc3RhdXJhbnQgJHtyZXN0YXVyYW50fSwgd2lsbCBzYXZlIHRvIGFsbCBhY3RpdmUgdmVuZG9yc2ApO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBHZXQgYWxsIHZlbmRvciBVSURzIGZyb20gZWF0ZXJpZXMgY29sbGVjdGlvblxyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY29uc3QgYWxsRWF0ZXJpZXNTbmFwc2hvdCA9IGF3YWl0IGdldERvY3MoY29sbGVjdGlvbihkYiwgJ2VhdGVyaWVzJykpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgKGFsbEVhdGVyaWVzU25hcHNob3QuZG9jcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgYWxsVmVuZG9yVUlEcyA9IGFsbEVhdGVyaWVzU25hcHNob3QuZG9jcy5tYXAoZG9jID0+IGRvYy5pZCk7XHJcbiAgICAgICAgICAgICAgdmVuZG9yVUlEcy5wdXNoKC4uLmFsbFZlbmRvclVJRHMpO1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OLIEZvdW5kICR7YWxsVmVuZG9yVUlEcy5sZW5ndGh9IGFjdGl2ZSB2ZW5kb3JzOmAsIGFsbFZlbmRvclVJRHMpO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OtIE5vIGVhdGVyaWVzIGNvbGxlY3Rpb24gZm91bmQuIENyZWF0aW5nIHZlbmRvciBlbnRyeSBmb3IgY3VycmVudCBkZW1vIHVzZXIuYCk7XHJcbiAgICAgICAgICAgICAgLy8gSWYgbm8gZWF0ZXJpZXMgZXhpc3QsIGNyZWF0ZSBvbmUgZm9yIHRoZSBkZW1vIHZlbmRvclxyXG4gICAgICAgICAgICAgIHZlbmRvclVJRHMucHVzaCgnMEdJM01valZuTGZ2elNFcU1jMjVvQ3pBbUN6MicpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9IGNhdGNoIChhbGxWZW5kb3JzRXJyb3IpIHtcclxuICAgICAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gQ291bGQgbm90IGdldCBhbGwgdmVuZG9ycywgdXNpbmcgZmFsbGJhY2sgVUlEcycpO1xyXG4gICAgICAgICAgICAvLyBGYWxsYmFjayB0byBrbm93biBVSURzIGlmIHRoZSBxdWVyeSBmYWlsc1xyXG4gICAgICAgICAgICB2ZW5kb3JVSURzLnB1c2goJzBHSTNNb2pWbkxmdnpTRXFNYzI1b0N6QW1DejInKTsgLy8gQ3VycmVudCBkZW1vIHZlbmRvclxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgY29uc29sZS5sb2coYPCfjq8gV2lsbCBzYXZlIG9yZGVyIHRvICR7dmVuZG9yVUlEcy5sZW5ndGh9IHZlbmRvcihzKTpgLCB2ZW5kb3JVSURzKTtcclxuXHJcbiAgICAgICAgLy8gU2F2ZSBvcmRlciB0byBlYWNoIHZlbmRvcidzIGNvbGxlY3Rpb25cclxuICAgICAgICBmb3IgKGNvbnN0IGN1cnJlbnRWZW5kb3JVSUQgb2YgdmVuZG9yVUlEcykge1xyXG4gICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gRmlyc3QsIGVuc3VyZSB0aGUgdmVuZG9yJ3MgZWF0ZXJ5IGRvY3VtZW50IGV4aXN0c1xyXG4gICAgICAgICAgICBjb25zdCBlYXRlcnlEb2NSZWYgPSBkb2MoZGIsICdlYXRlcmllcycsIGN1cnJlbnRWZW5kb3JVSUQpO1xyXG4gICAgICAgICAgICBhd2FpdCBzZXREb2MoZWF0ZXJ5RG9jUmVmLCB7XHJcbiAgICAgICAgICAgICAgaWQ6IGN1cnJlbnRWZW5kb3JVSUQsXHJcbiAgICAgICAgICAgICAgbmFtZTogcmVzdGF1cmFudE5hbWUgfHwgJ1Jlc3RhdXJhbnQnLCAvLyBVc2UgYWN0dWFsIHJlc3RhdXJhbnQgbmFtZVxyXG4gICAgICAgICAgICAgIGVtYWlsOiAndmVuZG9yQGNob3BjaG9wLmNvbScsXHJcbiAgICAgICAgICAgICAgY3JlYXRlZEF0OiBzZXJ2ZXJUaW1lc3RhbXAoKSxcclxuICAgICAgICAgICAgICByZXN0YXVyYW50SWRzOiBbcmVzdGF1cmFudF0gLy8gTWFwIHRoaXMgdmVuZG9yIHRvIHRoaXMgcmVzdGF1cmFudFxyXG4gICAgICAgICAgICB9LCB7IG1lcmdlOiB0cnVlIH0pOyAvLyBtZXJnZTogdHJ1ZSBtZWFucyBvbmx5IHVwZGF0ZSBpZiBkb2N1bWVudCBkb2Vzbid0IGV4aXN0XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEVuc3VyZWQgZWF0ZXJ5IGRvY3VtZW50IGV4aXN0cyBmb3IgdmVuZG9yOiAke2N1cnJlbnRWZW5kb3JVSUR9YCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCB2ZW5kb3JPcmRlckRhdGEgPSB7XHJcbiAgICAgICAgICAgICAgLy8gVXNlIHRoZSBleGFjdCBzYW1lIHN0cnVjdHVyZSB0aGF0IE1lbnVWZXJzZSBleHBlY3RzXHJcbiAgICAgICAgICAgICAgaWQ6IGRvY1JlZi5pZCxcclxuICAgICAgICAgICAgICBlYXRlcnlJZDogY3VycmVudFZlbmRvclVJRCxcclxuICAgICAgICAgICAgICBjdXN0b21lcjoge1xyXG4gICAgICAgICAgICAgICAgbmFtZTogY3VzdG9tZXI/Lm5hbWUgfHwgJ0Nob3BDaG9wIEN1c3RvbWVyJyxcclxuICAgICAgICAgICAgICAgIGVtYWlsOiBjdXN0b21lcj8uZW1haWwgfHwgJ2N1c3RvbWVyQGNob3BjaG9wLmNvbScsXHJcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzPy5kZWxpdmVyeUFkZHJlc3MgfHwgY3VzdG9tZXI/LmFkZHJlc3MgfHwgJ05vIGFkZHJlc3MgcHJvdmlkZWQnXHJcbiAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICBpdGVtczogb3JkZXJJbnB1dC5tYXAoKGl0ZW0sIGluZGV4KSA9PiAoe1xyXG4gICAgICAgICAgICAgICAgaWQ6IGAke2RvY1JlZi5pZH0taXRlbS0ke2luZGV4fWAsXHJcbiAgICAgICAgICAgICAgICBuYW1lOiBpdGVtLnRpdGxlLFxyXG4gICAgICAgICAgICAgICAgcXVhbnRpdHk6IGl0ZW0ucXVhbnRpdHksXHJcbiAgICAgICAgICAgICAgICBwcmljZTogaXRlbS5wcmljZVxyXG4gICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICB0b3RhbEFtb3VudDogb3JkZXJBbW91bnQsXHJcbiAgICAgICAgICAgICAgc3RhdHVzOiBvcmRlclN0YXR1cyA9PT0gJ1BFTkRJTkcnID8gJ1BlbmRpbmcnIDogXHJcbiAgICAgICAgICAgICAgICAgICAgIG9yZGVyU3RhdHVzID09PSAnQ09ORklSTUVEJyA/ICdDb25maXJtZWQnIDogJ1BlbmRpbmcnLFxyXG4gICAgICAgICAgICAgIGNyZWF0ZWRBdDogZmlyZXN0b3JlT3JkZXIuY3JlYXRlZEF0LFxyXG4gICAgICAgICAgICAgIC8vIEFkZGl0aW9uYWwgQ2hvcENob3Agc3BlY2lmaWMgZmllbGRzXHJcbiAgICAgICAgICAgICAgb3JkZXJJZDogb3JkZXJDb2RlLFxyXG4gICAgICAgICAgICAgIHJlc3RhdXJhbnRJZDogcmVzdGF1cmFudCxcclxuICAgICAgICAgICAgICBwYXltZW50TWV0aG9kLFxyXG4gICAgICAgICAgICAgIHBsYXRmb3JtOiAnQ2hvcENob3AnXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBjb25zdCB2ZW5kb3JQYXRoID0gYGVhdGVyaWVzLyR7Y3VycmVudFZlbmRvclVJRH0vb3JkZXJzYDtcclxuICAgICAgICAgICAgY29uc3QgdmVuZG9yRG9jUmVmID0gYXdhaXQgYWRkRG9jKGNvbGxlY3Rpb24oZGIsICdlYXRlcmllcycsIGN1cnJlbnRWZW5kb3JVSUQsICdvcmRlcnMnKSwgdmVuZG9yT3JkZXJEYXRhKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgT3JkZXIgJHtvcmRlckNvZGV9IHNhdmVkIHRvIHZlbmRvciBwYXRoOiAke3ZlbmRvclBhdGh9IHdpdGggSUQ6ICR7dmVuZG9yRG9jUmVmLmlkfWApO1xyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhg8J+TiiBPcmRlciBkYXRhIHNhdmVkOmAsIHZlbmRvck9yZGVyRGF0YSk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn46vIFZFUklGSUNBVElPTjogT3JkZXIgc2hvdWxkIGJlIHZpc2libGUgYXQgRmlyZWJhc2UgcGF0aDogZWF0ZXJpZXMvJHtjdXJyZW50VmVuZG9yVUlEfS9vcmRlcnMvJHt2ZW5kb3JEb2NSZWYuaWR9YCk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAvLyDwn5SEIFNZTkMgVE8gQ1VTVE9NRVIgT1JERVJTOiBTYXZlIG9yZGVyIHRvIGN1c3RvbWVyLWFjY2Vzc2libGUgY29sbGVjdGlvblxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGN1c3RvbWVyT3JkZXJJZCA9IGF3YWl0IE9yZGVyU3luY1NlcnZpY2Uuc2F2ZUN1c3RvbWVyT3JkZXIoe1xyXG4gICAgICAgICAgICAgICAgb3JkZXJJZDogb3JkZXJDb2RlLFxyXG4gICAgICAgICAgICAgICAgY3VzdG9tZXJJZDogdXNlcklkIHx8IGN1c3RvbWVyPy5lbWFpbCB8fCBgY3VzdG9tZXItJHtEYXRlLm5vdygpfWAsIC8vIFVzZSB1c2VySWQgaWYgYXZhaWxhYmxlLCBmYWxsYmFjayB0byBlbWFpbFxyXG4gICAgICAgICAgICAgICAgdmVuZG9ySWQ6IGN1cnJlbnRWZW5kb3JVSUQsXHJcbiAgICAgICAgICAgICAgICByZXN0YXVyYW50SWQ6IHJlc3RhdXJhbnQsXHJcbiAgICAgICAgICAgICAgICByZXN0YXVyYW50TmFtZTogcmVzdGF1cmFudE5hbWUgfHwgJ1Jlc3RhdXJhbnQnLFxyXG4gICAgICAgICAgICAgICAgY3VzdG9tZXI6IHtcclxuICAgICAgICAgICAgICAgICAgbmFtZTogY3VzdG9tZXI/Lm5hbWUgfHwgJ0Nob3BDaG9wIEN1c3RvbWVyJyxcclxuICAgICAgICAgICAgICAgICAgZW1haWw6IGN1c3RvbWVyPy5lbWFpbCB8fCAnY3VzdG9tZXJAY2hvcGNob3AuY29tJyxcclxuICAgICAgICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcz8uZGVsaXZlcnlBZGRyZXNzIHx8IGN1c3RvbWVyPy5hZGRyZXNzIHx8ICdObyBhZGRyZXNzIHByb3ZpZGVkJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGl0ZW1zOiBvcmRlcklucHV0Lm1hcCgoaXRlbSwgaW5kZXgpID0+ICh7XHJcbiAgICAgICAgICAgICAgICAgIGlkOiBgJHtvcmRlckNvZGV9LWl0ZW0tJHtpbmRleH1gLFxyXG4gICAgICAgICAgICAgICAgICBuYW1lOiBpdGVtLnRpdGxlLFxyXG4gICAgICAgICAgICAgICAgICBxdWFudGl0eTogaXRlbS5xdWFudGl0eSxcclxuICAgICAgICAgICAgICAgICAgcHJpY2U6IGl0ZW0ucHJpY2VcclxuICAgICAgICAgICAgICAgIH0pKSxcclxuICAgICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBvcmRlckFtb3VudCxcclxuICAgICAgICAgICAgICAgIHN0YXR1czogb3JkZXJTdGF0dXMgPT09ICdQRU5ESU5HJyA/ICdQZW5kaW5nJyA6IFxyXG4gICAgICAgICAgICAgICAgICAgICAgIG9yZGVyU3RhdHVzID09PSAnQ09ORklSTUVEJyA/ICdDb25maXJtZWQnIDogJ1BlbmRpbmcnLFxyXG4gICAgICAgICAgICAgICAgcGF5bWVudE1ldGhvZDogcGF5bWVudE1ldGhvZFxyXG4gICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGlmIChjdXN0b21lck9yZGVySWQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgQ3VzdG9tZXIgb3JkZXIgc3luY2VkOiBjdXN0b21lci1vcmRlcnMvJHtjdXN0b21lck9yZGVySWR9YCk7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChzeW5jRXJyb3IpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBGYWlsZWQgdG8gc3luYyBjdXN0b21lciBvcmRlcjonLCBzeW5jRXJyb3IpO1xyXG4gICAgICAgICAgICAgIC8vIERvbid0IGZhaWwgdGhlIG1haW4gb3JkZXIgLSB0aGlzIGlzIHN1cHBsZW1lbnRhcnlcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgIH0gY2F0Y2ggKHBhdGhFcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGDinYwgRmFpbGVkIHRvIHNhdmUgdG8gdmVuZG9yIFVJRCAke2N1cnJlbnRWZW5kb3JVSUR9OmAsIHBhdGhFcnJvcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJTVBPUlRBTlQ6IExldCdzIGFsc28gdHJ5IHRvIHNhdmUgdG8gYSBwcmVkaWN0YWJsZSBwYXRoIGZvciB0ZXN0aW5nXHJcbiAgICAgICAgLy8gVGhpcyB3aWxsIGhlbHAgdXMgZGVidWcgd2hhdCdzIGhhcHBlbmluZ1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCBkZWJ1Z09yZGVyRGF0YSA9IHtcclxuICAgICAgICAgICAgaWQ6IGRvY1JlZi5pZCxcclxuICAgICAgICAgICAgZWF0ZXJ5SWQ6ICdERUJVR19WRU5ET1InLFxyXG4gICAgICAgICAgICBjdXN0b21lcjogeyBuYW1lOiAnRGVidWcgQ3VzdG9tZXInLCBlbWFpbDogJ2RlYnVnQHRlc3QuY29tJywgYWRkcmVzczogJ0RlYnVnIEFkZHJlc3MnIH0sXHJcbiAgICAgICAgICAgIGl0ZW1zOiBbeyBpZDogJ2RlYnVnLWl0ZW0nLCBuYW1lOiAnRGVidWcgSXRlbScsIHF1YW50aXR5OiAxLCBwcmljZTogMTAuOTkgfV0sXHJcbiAgICAgICAgICAgIHRvdGFsQW1vdW50OiAxMC45OSxcclxuICAgICAgICAgICAgc3RhdHVzOiAnUGVuZGluZycsXHJcbiAgICAgICAgICAgIGNyZWF0ZWRBdDogZmlyZXN0b3JlT3JkZXIuY3JlYXRlZEF0LFxyXG4gICAgICAgICAgICBkZWJ1Z0luZm86IHtcclxuICAgICAgICAgICAgICBvcmlnaW5hbFJlc3RhdXJhbnRJZDogcmVzdGF1cmFudCxcclxuICAgICAgICAgICAgICBvcmRlckNvZGU6IG9yZGVyQ29kZSxcclxuICAgICAgICAgICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgICAgICBzb3VyY2U6ICdDaG9wQ2hvcCBEZWJ1ZyBTYXZlJ1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9O1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBhd2FpdCBhZGREb2MoY29sbGVjdGlvbihkYiwgJ2VhdGVyaWVzJywgJ0RFQlVHX1ZFTkRPUicsICdvcmRlcnMnKSwgZGVidWdPcmRlckRhdGEpO1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYPCfkJsgREVCVUc6IE9yZGVyIHNhdmVkIHRvIGVhdGVyaWVzL0RFQlVHX1ZFTkRPUi9vcmRlcnMgZm9yIHRlc3RpbmdgKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgIH0gY2F0Y2ggKGRlYnVnRXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybignRGVidWcgc2F2ZSBmYWlsZWQ6JywgZGVidWdFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICB9IGNhdGNoICh2ZW5kb3JFcnJvcikge1xyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KaoO+4jyBGYWlsZWQgdG8gc2F2ZSB0byB2ZW5kb3IgY29sbGVjdGlvbnM6JywgdmVuZG9yRXJyb3IpO1xyXG4gICAgICAgIC8vIERvbid0IHRocm93IC0gZ2xvYmFsIG9yZGVyIHdhcyBzYXZlZCBzdWNjZXNzZnVsbHlcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBvcmRlcklkOiBvcmRlckNvZGUsXHJcbiAgICAgICAgb3JkZXJTdGF0dXMsXHJcbiAgICAgICAgdG90YWw6IG9yZGVyQW1vdW50LFxyXG4gICAgICAgIGZpcmViYXNlSWQ6IGRvY1JlZi5pZFxyXG4gICAgICB9O1xyXG4gICAgICBcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGaXJlYmFzZSBvcmRlciBjcmVhdGlvbiBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwbGFjZSBvcmRlcjogJHtlcnJvci5tZXNzYWdlfWApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgc3RhdGljIGFzeW5jIHVwZGF0ZU9yZGVyU3RhdHVzKGZpcmViYXNlSWQ6IHN0cmluZywgc3RhdHVzOiBzdHJpbmcsIHBhaWRBbW91bnQ/OiBudW1iZXIpIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHsgdXBkYXRlRG9jLCBkb2MgfSA9IGF3YWl0IGltcG9ydCgnZmlyZWJhc2UvZmlyZXN0b3JlJyk7XHJcbiAgICAgIGNvbnN0IG9yZGVyUmVmID0gZG9jKGRiLCAnb3JkZXJzJywgZmlyZWJhc2VJZCk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB1cGRhdGVEYXRhOiBhbnkgPSB7XHJcbiAgICAgICAgb3JkZXJTdGF0dXM6IHN0YXR1cyxcclxuICAgICAgICB1cGRhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpXHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgICBpZiAocGFpZEFtb3VudCAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdXBkYXRlRGF0YS5wYWlkQW1vdW50ID0gcGFpZEFtb3VudDtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgYXdhaXQgdXBkYXRlRG9jKG9yZGVyUmVmLCB1cGRhdGVEYXRhKTtcclxuICAgICAgY29uc29sZS5sb2coYOKchSBPcmRlciAke2ZpcmViYXNlSWR9IHN0YXR1cyB1cGRhdGVkIHRvICR7c3RhdHVzfWApO1xyXG4gICAgICBcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBGaXJlYmFzZSBvcmRlciB1cGRhdGUgZmFpbGVkOicsIGVycm9yKTtcclxuICAgICAgdGhyb3cgZXJyb3I7XHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBPcmRlclNlcnZpY2U7Il0sIm5hbWVzIjpbImdldEZpcmVzdG9yZSIsImNvbGxlY3Rpb24iLCJhZGREb2MiLCJzZXJ2ZXJUaW1lc3RhbXAiLCJnZXREb2NzIiwiZG9jIiwic2V0RG9jIiwiZ2V0RmlyZWJhc2VBcHAiLCJkYiIsIk9yZGVyU2VydmljZSIsInBsYWNlT3JkZXIiLCJyZXN0YXVyYW50IiwicmVzdGF1cmFudE5hbWUiLCJvcmRlcklucHV0IiwicGF5bWVudE1ldGhvZCIsImFkZHJlc3MiLCJjdXN0b21lciIsImRlbGl2ZXJ5Q2hhcmdlcyIsInRpcHBpbmciLCJ0YXhhdGlvbkFtb3VudCIsImluc3RydWN0aW9ucyIsImlzUGlja2VkVXAiLCJzdWJ0b3RhbCIsInJlZHVjZSIsInN1bSIsIml0ZW0iLCJwcmljZSIsInF1YW50aXR5Iiwib3JkZXJBbW91bnQiLCJvcmRlclN0YXR1cyIsInBhaWRBbW91bnQiLCJvcmRlckNvZGUiLCJEYXRlIiwibm93IiwiZmlyZXN0b3JlT3JkZXIiLCJvcmRlcklkIiwicmVzdGF1cmFudElkIiwib3JkZXJEYXRlIiwidG9JU09TdHJpbmciLCJjcmVhdGVkQXQiLCJpdGVtcyIsInZlbmRvck5vdGlmaWVkIiwib3JkZXJUeXBlIiwicGxhdGZvcm0iLCJkZWxpdmVyeUFkZHJlc3MiLCJsYXRpdHVkZSIsInVuZGVmaW5lZCIsImRlbGl2ZXJ5TGF0aXR1ZGUiLCJsb25naXR1ZGUiLCJkZWxpdmVyeUxvbmdpdHVkZSIsImRvY1JlZiIsImNvbnNvbGUiLCJsb2ciLCJpZCIsInZlbmRvclVJRCIsImVhdGVyaWVzU25hcHNob3QiLCJkb2NzIiwiZWF0ZXJ5RGF0YSIsImRhdGEiLCJyZXN0YXVyYW50SWRzIiwiaW5jbHVkZXMiLCJsb29rdXBFcnJvciIsIndhcm4iLCJ2ZW5kb3JVSURzIiwicHVzaCIsImFsbEVhdGVyaWVzU25hcHNob3QiLCJsZW5ndGgiLCJhbGxWZW5kb3JVSURzIiwibWFwIiwiYWxsVmVuZG9yc0Vycm9yIiwiY3VycmVudFZlbmRvclVJRCIsImVhdGVyeURvY1JlZiIsIm5hbWUiLCJlbWFpbCIsIm1lcmdlIiwidmVuZG9yT3JkZXJEYXRhIiwiZWF0ZXJ5SWQiLCJpbmRleCIsInRpdGxlIiwidG90YWxBbW91bnQiLCJzdGF0dXMiLCJ2ZW5kb3JQYXRoIiwidmVuZG9yRG9jUmVmIiwiY3VzdG9tZXJPcmRlcklkIiwiT3JkZXJTeW5jU2VydmljZSIsInNhdmVDdXN0b21lck9yZGVyIiwiY3VzdG9tZXJJZCIsInVzZXJJZCIsInZlbmRvcklkIiwic3luY0Vycm9yIiwicGF0aEVycm9yIiwiZXJyb3IiLCJkZWJ1Z09yZGVyRGF0YSIsImRlYnVnSW5mbyIsIm9yaWdpbmFsUmVzdGF1cmFudElkIiwidGltZXN0YW1wIiwic291cmNlIiwiZGVidWdFcnJvciIsInZlbmRvckVycm9yIiwidG90YWwiLCJmaXJlYmFzZUlkIiwiRXJyb3IiLCJtZXNzYWdlIiwidXBkYXRlT3JkZXJTdGF0dXMiLCJ1cGRhdGVEb2MiLCJvcmRlclJlZiIsInVwZGF0ZURhdGEiLCJ1cGRhdGVkQXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./lib/firebase/orders.ts\n"));

/***/ })

});