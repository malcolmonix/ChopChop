"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/checkout",{

/***/ "./lib/firebase/orders.ts":
/*!********************************!*\
  !*** ./lib/firebase/orders.ts ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrderService: function() { return /* binding */ OrderService; }\n/* harmony export */ });\n/* harmony import */ var firebase_firestore__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/firestore */ \"./node_modules/firebase/firestore/dist/esm/index.esm.js\");\n/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client */ \"./lib/firebase/client.ts\");\n\n\n// import { OrderSyncService } from './order-sync'; // Temporarily disabled to fix build\n// Initialize Firestore\nconst db = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getFirestore)((0,_client__WEBPACK_IMPORTED_MODULE_1__.getFirebaseApp)());\nclass OrderService {\n    static async placeOrder(param) {\n        let { restaurant, restaurantName, orderInput, paymentMethod, address, customer, deliveryCharges = 0, tipping = 0, taxationAmount = 0, instructions = \"\", isPickedUp = false } = param;\n        try {\n            // Calculate order details\n            const subtotal = orderInput.reduce((sum, item)=>sum + item.price * item.quantity, 0);\n            const orderAmount = subtotal + deliveryCharges + tipping + taxationAmount;\n            // Determine order status based on payment method\n            let orderStatus = \"PENDING\";\n            let paidAmount = 0;\n            if (paymentMethod === \"CASH\") {\n                orderStatus = \"PENDING\"; // Will be paid on delivery\n                paidAmount = 0;\n            } else if (paymentMethod === \"CARD\" || paymentMethod === \"WALLET\") {\n                orderStatus = \"CONFIRMED\"; // Electronic payments - assume paid immediately\n                paidAmount = orderAmount;\n            } else if (paymentMethod === \"BANK\") {\n                orderStatus = \"PAYMENT_PENDING\"; // Bank transfer - awaiting verification\n                paidAmount = 0;\n            }\n            const orderCode = \"CC\".concat(Date.now());\n            // Create Firebase order object (removing undefined values)\n            const firestoreOrder = {\n                orderId: orderCode,\n                restaurantId: restaurant,\n                orderStatus,\n                paymentMethod,\n                orderAmount,\n                paidAmount,\n                deliveryCharges,\n                tipping,\n                taxationAmount,\n                orderDate: new Date().toISOString(),\n                isPickedUp,\n                createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                items: orderInput,\n                // Vendor notification fields for MenuVerse integration\n                vendorNotified: false,\n                orderType: \"delivery\",\n                platform: \"ChopChop\"\n            };\n            // Only add optional fields if they have values\n            if (address === null || address === void 0 ? void 0 : address.deliveryAddress) {\n                firestoreOrder.deliveryAddress = address.deliveryAddress;\n            }\n            if ((address === null || address === void 0 ? void 0 : address.latitude) !== undefined) {\n                firestoreOrder.deliveryLatitude = address.latitude;\n            }\n            if ((address === null || address === void 0 ? void 0 : address.longitude) !== undefined) {\n                firestoreOrder.deliveryLongitude = address.longitude;\n            }\n            if (instructions) {\n                firestoreOrder.instructions = instructions;\n            }\n            // Save to Firebase orders collection\n            const docRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"orders\"), firestoreOrder);\n            console.log(\"‚úÖ Order \".concat(orderCode, \" saved to Firebase with ID:\"), docRef.id);\n            // ALSO save to vendor-specific collection for MenuVerse notifications\n            console.log(\"\\uD83D\\uDE80 STARTING vendor save process for order \".concat(orderCode, \"...\"));\n            try {\n                // Dynamic restaurant-to-vendor mapping\n                // In production, this would come from a database lookup\n                // For now, we'll try to find the vendor UID dynamically\n                console.log(\"\\uD83D\\uDD0D Looking up vendor for restaurant ID: \".concat(restaurant));\n                // Method 1: Try to find vendor by querying the eateries collection\n                let vendorUID = null;\n                try {\n                    // Query the eateries collection to find which vendor owns this restaurant\n                    const eateriesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"eateries\"));\n                    for (const doc of eateriesSnapshot.docs){\n                        const eateryData = doc.data();\n                        // Check if this eatery has this restaurant ID\n                        // This assumes the eatery document has a restaurantIds array or similar\n                        if (eateryData.restaurantIds && eateryData.restaurantIds.includes(restaurant)) {\n                            vendorUID = doc.id;\n                            console.log(\"‚úÖ Found vendor \".concat(vendorUID, \" for restaurant \").concat(restaurant));\n                            break;\n                        }\n                        // Alternative: check if restaurant ID matches the eatery ID\n                        if (eateryData.id === restaurant || eateryData.restaurantId === restaurant) {\n                            vendorUID = doc.id;\n                            console.log(\"‚úÖ Found vendor \".concat(vendorUID, \" for restaurant \").concat(restaurant, \" (direct match)\"));\n                            break;\n                        }\n                    }\n                } catch (lookupError) {\n                    console.warn(\"‚ö†Ô∏è Could not lookup vendor from eateries collection:\", lookupError);\n                }\n                // Method 2: If no specific mapping found, save to all active vendors\n                // This ensures orders don't get lost while the mapping system is being set up\n                const vendorUIDs = [];\n                if (vendorUID) {\n                    vendorUIDs.push(vendorUID);\n                } else {\n                    console.log(\"\\uD83D\\uDD04 No specific vendor found for restaurant \".concat(restaurant, \", will save to all active vendors\"));\n                    // Get all vendor UIDs from eateries collection\n                    try {\n                        const allEateriesSnapshot = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.getDocs)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"eateries\"));\n                        if (allEateriesSnapshot.docs.length > 0) {\n                            const allVendorUIDs = allEateriesSnapshot.docs.map((doc)=>doc.id);\n                            vendorUIDs.push(...allVendorUIDs);\n                            console.log(\"\\uD83D\\uDCCB Found \".concat(allVendorUIDs.length, \" active vendors:\"), allVendorUIDs);\n                        } else {\n                            console.log(\"\\uD83D\\uDCED No eateries collection found. Creating vendor entry for current demo user.\");\n                            // If no eateries exist, create one for the demo vendor\n                            vendorUIDs.push(\"0GI3MojVnLfvzSEqMc25oCzAmCz2\");\n                        }\n                    } catch (allVendorsError) {\n                        console.warn(\"‚ö†Ô∏è Could not get all vendors, using fallback UIDs\");\n                        // Fallback to known UIDs if the query fails\n                        vendorUIDs.push(\"0GI3MojVnLfvzSEqMc25oCzAmCz2\"); // Current demo vendor\n                    }\n                }\n                console.log(\"\\uD83C\\uDFAF Will save order to \".concat(vendorUIDs.length, \" vendor(s):\"), vendorUIDs);\n                // Save order to each vendor's collection\n                for (const currentVendorUID of vendorUIDs){\n                    try {\n                        // First, ensure the vendor's eatery document exists\n                        const eateryDocRef = (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.doc)(db, \"eateries\", currentVendorUID);\n                        await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.setDoc)(eateryDocRef, {\n                            id: currentVendorUID,\n                            name: restaurantName || \"Restaurant\",\n                            email: \"vendor@chopchop.com\",\n                            createdAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)(),\n                            restaurantIds: [\n                                restaurant\n                            ] // Map this vendor to this restaurant\n                        }, {\n                            merge: true\n                        }); // merge: true means only update if document doesn't exist\n                        console.log(\"‚úÖ Ensured eatery document exists for vendor: \".concat(currentVendorUID));\n                        const vendorOrderData = {\n                            // Use the exact same structure that MenuVerse expects\n                            id: docRef.id,\n                            eateryId: currentVendorUID,\n                            customer: {\n                                name: (customer === null || customer === void 0 ? void 0 : customer.name) || \"ChopChop Customer\",\n                                email: (customer === null || customer === void 0 ? void 0 : customer.email) || \"customer@chopchop.com\",\n                                address: (address === null || address === void 0 ? void 0 : address.deliveryAddress) || (customer === null || customer === void 0 ? void 0 : customer.address) || \"No address provided\"\n                            },\n                            items: orderInput.map((item, index)=>({\n                                    id: \"\".concat(docRef.id, \"-item-\").concat(index),\n                                    name: item.title,\n                                    quantity: item.quantity,\n                                    price: item.price\n                                })),\n                            totalAmount: orderAmount,\n                            status: orderStatus === \"PENDING\" ? \"Pending\" : orderStatus === \"CONFIRMED\" ? \"Confirmed\" : \"Pending\",\n                            createdAt: firestoreOrder.createdAt,\n                            // Additional ChopChop specific fields\n                            orderId: orderCode,\n                            restaurantId: restaurant,\n                            paymentMethod,\n                            platform: \"ChopChop\"\n                        };\n                        const vendorPath = \"eateries/\".concat(currentVendorUID, \"/orders\");\n                        const vendorDocRef = await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"eateries\", currentVendorUID, \"orders\"), vendorOrderData);\n                        console.log(\"‚úÖ Order \".concat(orderCode, \" saved to vendor path: \").concat(vendorPath, \" with ID: \").concat(vendorDocRef.id));\n                        console.log(\"\\uD83D\\uDCCA Order data saved:\", vendorOrderData);\n                        console.log(\"\\uD83C\\uDFAF VERIFICATION: Order should be visible at Firebase path: eateries/\".concat(currentVendorUID, \"/orders/\").concat(vendorDocRef.id));\n                    // üîÑ SYNC TO CUSTOMER ORDERS: Save order to customer-accessible collection\n                    // Temporarily disabled to fix build issue\n                    /*\r\n            try {\r\n              const customerOrderId = await OrderSyncService.saveCustomerOrder({\r\n                orderId: orderCode,\r\n                customerId: customer?.email || `customer-${Date.now()}`, // Use email as customer ID\r\n                vendorId: currentVendorUID,\r\n                restaurantId: restaurant,\r\n                restaurantName: restaurantName || 'Restaurant', // Use actual restaurant name\r\n                customer: {\r\n                  name: customer?.name || 'ChopChop Customer',\r\n                  email: customer?.email || 'customer@chopchop.com',\r\n                  address: address?.deliveryAddress || customer?.address || 'No address provided'\r\n                },\r\n                items: orderInput.map((item, index) => ({\r\n                  id: `${orderCode}-item-${index}`,\r\n                  name: item.title,\r\n                  quantity: item.quantity,\r\n                  price: item.price\r\n                })),\r\n                totalAmount: orderAmount,\r\n                status: orderStatus === 'PENDING' ? 'Pending' : \r\n                       orderStatus === 'CONFIRMED' ? 'Confirmed' : 'Pending',\r\n                paymentMethod: paymentMethod\r\n              });\r\n              \r\n              if (customerOrderId) {\r\n                console.log(`‚úÖ Customer order synced: customer-orders/${customerOrderId}`);\r\n              }\r\n            } catch (syncError) {\r\n              console.warn('‚ö†Ô∏è Failed to sync customer order:', syncError);\r\n              // Don't fail the main order - this is supplementary\r\n            }\r\n            */ } catch (pathError) {\n                        console.error(\"‚ùå Failed to save to vendor UID \".concat(currentVendorUID, \":\"), pathError);\n                    }\n                }\n                // IMPORTANT: Let's also try to save to a predictable path for testing\n                // This will help us debug what's happening\n                try {\n                    const debugOrderData = {\n                        id: docRef.id,\n                        eateryId: \"DEBUG_VENDOR\",\n                        customer: {\n                            name: \"Debug Customer\",\n                            email: \"debug@test.com\",\n                            address: \"Debug Address\"\n                        },\n                        items: [\n                            {\n                                id: \"debug-item\",\n                                name: \"Debug Item\",\n                                quantity: 1,\n                                price: 10.99\n                            }\n                        ],\n                        totalAmount: 10.99,\n                        status: \"Pending\",\n                        createdAt: firestoreOrder.createdAt,\n                        debugInfo: {\n                            originalRestaurantId: restaurant,\n                            orderCode: orderCode,\n                            timestamp: new Date().toISOString(),\n                            source: \"ChopChop Debug Save\"\n                        }\n                    };\n                    await (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.addDoc)((0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.collection)(db, \"eateries\", \"DEBUG_VENDOR\", \"orders\"), debugOrderData);\n                    console.log(\"\\uD83D\\uDC1B DEBUG: Order saved to eateries/DEBUG_VENDOR/orders for testing\");\n                } catch (debugError) {\n                    console.warn(\"Debug save failed:\", debugError);\n                }\n            } catch (vendorError) {\n                console.error(\"‚ö†Ô∏è Failed to save to vendor collections:\", vendorError);\n            // Don't throw - global order was saved successfully\n            }\n            return {\n                orderId: orderCode,\n                orderStatus,\n                total: orderAmount,\n                firebaseId: docRef.id\n            };\n        } catch (error) {\n            console.error(\"‚ùå Firebase order creation failed:\", error);\n            throw new Error(\"Failed to place order: \".concat(error.message));\n        }\n    }\n    static async updateOrderStatus(firebaseId, status, paidAmount) {\n        try {\n            const { updateDoc, doc } = await Promise.resolve(/*! import() */).then(__webpack_require__.bind(__webpack_require__, /*! firebase/firestore */ \"./node_modules/firebase/firestore/dist/esm/index.esm.js\"));\n            const orderRef = doc(db, \"orders\", firebaseId);\n            const updateData = {\n                orderStatus: status,\n                updatedAt: (0,firebase_firestore__WEBPACK_IMPORTED_MODULE_0__.serverTimestamp)()\n            };\n            if (paidAmount !== undefined) {\n                updateData.paidAmount = paidAmount;\n            }\n            await updateDoc(orderRef, updateData);\n            console.log(\"‚úÖ Order \".concat(firebaseId, \" status updated to \").concat(status));\n        } catch (error) {\n            console.error(\"‚ùå Firebase order update failed:\", error);\n            throw error;\n        }\n    }\n}\n/* harmony default export */ __webpack_exports__[\"default\"] = (OrderService);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1lBQ3hDLE1BQU02RixXQUFXN0YsSUFBSUcsSUFBSSxVQUFVcUY7WUFFbkMsTUFBTU0sYUFBa0I7Z0JBQ3RCdEUsYUFBYW1EO2dCQUNib0IsV0FBV2pHLG1FQUFlQTtZQUM1QjtZQUVBLElBQUkyQixlQUFlZ0IsV0FBVztnQkFDNUJxRCxXQUFXckUsVUFBVSxHQUFHQTtZQUMxQjtZQUVBLE1BQU1tRSxVQUFVQyxVQUFVQztZQUMxQmhELFFBQVFDLEdBQUcsQ0FBQyxXQUEyQzRCLE9BQWhDYSxZQUFXLHVCQUE0QixPQUFQYjtRQUV6RCxFQUFFLE9BQU9JLE9BQU87WUFDZGpDLFFBQVFpQyxLQUFLLENBQUMsbUNBQW1DQTtZQUNqRCxNQUFNQTtRQUNSO0lBQ0Y7QUFDRjtBQUVBLCtEQUFlM0UsWUFBWUEsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9saWIvZmlyZWJhc2Uvb3JkZXJzLnRzPzA5NGMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0RmlyZXN0b3JlLCBjb2xsZWN0aW9uLCBhZGREb2MsIHNlcnZlclRpbWVzdGFtcCwgZ2V0RG9jcywgZG9jLCBzZXREb2MgfSBmcm9tICdmaXJlYmFzZS9maXJlc3RvcmUnO1xyXG5pbXBvcnQgeyBnZXRGaXJlYmFzZUFwcCB9IGZyb20gJy4vY2xpZW50JztcclxuLy8gaW1wb3J0IHsgT3JkZXJTeW5jU2VydmljZSB9IGZyb20gJy4vb3JkZXItc3luYyc7IC8vIFRlbXBvcmFyaWx5IGRpc2FibGVkIHRvIGZpeCBidWlsZFxyXG5cclxuLy8gSW5pdGlhbGl6ZSBGaXJlc3RvcmVcclxuY29uc3QgZGIgPSBnZXRGaXJlc3RvcmUoZ2V0RmlyZWJhc2VBcHAoKSk7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIE9yZGVySXRlbSB7XHJcbiAgdGl0bGU6IHN0cmluZztcclxuICBxdWFudGl0eTogbnVtYmVyO1xyXG4gIHByaWNlOiBudW1iZXI7XHJcbiAgdmFyaWF0aW9uPzogc3RyaW5nO1xyXG4gIGFkZG9ucz86IHN0cmluZztcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBPcmRlckFkZHJlc3Mge1xyXG4gIGRlbGl2ZXJ5QWRkcmVzczogc3RyaW5nO1xyXG4gIGxhdGl0dWRlPzogbnVtYmVyO1xyXG4gIGxvbmdpdHVkZT86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBGaXJlYmFzZU9yZGVyIHtcclxuICBvcmRlcklkOiBzdHJpbmc7XHJcbiAgcmVzdGF1cmFudElkOiBudW1iZXI7XHJcbiAgb3JkZXJTdGF0dXM6IHN0cmluZztcclxuICBwYXltZW50TWV0aG9kOiBzdHJpbmc7XHJcbiAgb3JkZXJBbW91bnQ6IG51bWJlcjtcclxuICBwYWlkQW1vdW50OiBudW1iZXI7XHJcbiAgZGVsaXZlcnlBZGRyZXNzPzogc3RyaW5nO1xyXG4gIGRlbGl2ZXJ5TGF0aXR1ZGU/OiBudW1iZXI7XHJcbiAgZGVsaXZlcnlMb25naXR1ZGU/OiBudW1iZXI7XHJcbiAgaW5zdHJ1Y3Rpb25zPzogc3RyaW5nO1xyXG4gIGRlbGl2ZXJ5Q2hhcmdlczogbnVtYmVyO1xyXG4gIHRpcHBpbmc6IG51bWJlcjtcclxuICB0YXhhdGlvbkFtb3VudDogbnVtYmVyO1xyXG4gIG9yZGVyRGF0ZTogc3RyaW5nO1xyXG4gIGlzUGlja2VkVXA6IGJvb2xlYW47XHJcbiAgY3JlYXRlZEF0OiBhbnk7IC8vIHNlcnZlclRpbWVzdGFtcFxyXG4gIGl0ZW1zOiBPcmRlckl0ZW1bXTtcclxuICB2ZW5kb3JOb3RpZmllZDogYm9vbGVhbjtcclxuICBvcmRlclR5cGU6IHN0cmluZztcclxuICBwbGF0Zm9ybTogc3RyaW5nO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgT3JkZXJTZXJ2aWNlIHtcclxuICBzdGF0aWMgYXN5bmMgcGxhY2VPcmRlcih7XHJcbiAgICByZXN0YXVyYW50LFxyXG4gICAgcmVzdGF1cmFudE5hbWUsXHJcbiAgICBvcmRlcklucHV0LFxyXG4gICAgcGF5bWVudE1ldGhvZCxcclxuICAgIGFkZHJlc3MsXHJcbiAgICBjdXN0b21lcixcclxuICAgIGRlbGl2ZXJ5Q2hhcmdlcyA9IDAsXHJcbiAgICB0aXBwaW5nID0gMCxcclxuICAgIHRheGF0aW9uQW1vdW50ID0gMCxcclxuICAgIGluc3RydWN0aW9ucyA9ICcnLFxyXG4gICAgaXNQaWNrZWRVcCA9IGZhbHNlXHJcbiAgfToge1xyXG4gICAgcmVzdGF1cmFudDogbnVtYmVyO1xyXG4gICAgcmVzdGF1cmFudE5hbWU/OiBzdHJpbmc7XHJcbiAgICBvcmRlcklucHV0OiBPcmRlckl0ZW1bXTtcclxuICAgIHBheW1lbnRNZXRob2Q6IHN0cmluZztcclxuICAgIGFkZHJlc3M/OiBPcmRlckFkZHJlc3M7XHJcbiAgICBjdXN0b21lcj86IHtcclxuICAgICAgbmFtZTogc3RyaW5nO1xyXG4gICAgICBlbWFpbDogc3RyaW5nO1xyXG4gICAgICBhZGRyZXNzPzogc3RyaW5nO1xyXG4gICAgfTtcclxuICAgIGRlbGl2ZXJ5Q2hhcmdlcz86IG51bWJlcjtcclxuICAgIHRpcHBpbmc/OiBudW1iZXI7XHJcbiAgICB0YXhhdGlvbkFtb3VudD86IG51bWJlcjtcclxuICAgIGluc3RydWN0aW9ucz86IHN0cmluZztcclxuICAgIGlzUGlja2VkVXA/OiBib29sZWFuO1xyXG4gIH0pIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIENhbGN1bGF0ZSBvcmRlciBkZXRhaWxzXHJcbiAgICAgIGNvbnN0IHN1YnRvdGFsID0gb3JkZXJJbnB1dC5yZWR1Y2UoKHN1bSwgaXRlbSkgPT4gc3VtICsgKGl0ZW0ucHJpY2UgKiBpdGVtLnF1YW50aXR5KSwgMCk7XHJcbiAgICAgIGNvbnN0IG9yZGVyQW1vdW50ID0gc3VidG90YWwgKyBkZWxpdmVyeUNoYXJnZXMgKyB0aXBwaW5nICsgdGF4YXRpb25BbW91bnQ7XHJcbiAgICAgIFxyXG4gICAgICAvLyBEZXRlcm1pbmUgb3JkZXIgc3RhdHVzIGJhc2VkIG9uIHBheW1lbnQgbWV0aG9kXHJcbiAgICAgIGxldCBvcmRlclN0YXR1cyA9ICdQRU5ESU5HJztcclxuICAgICAgbGV0IHBhaWRBbW91bnQgPSAwO1xyXG4gICAgICBcclxuICAgICAgaWYgKHBheW1lbnRNZXRob2QgPT09ICdDQVNIJykge1xyXG4gICAgICAgIG9yZGVyU3RhdHVzID0gJ1BFTkRJTkcnOyAvLyBXaWxsIGJlIHBhaWQgb24gZGVsaXZlcnlcclxuICAgICAgICBwYWlkQW1vdW50ID0gMDtcclxuICAgICAgfSBlbHNlIGlmIChwYXltZW50TWV0aG9kID09PSAnQ0FSRCcgfHwgcGF5bWVudE1ldGhvZCA9PT0gJ1dBTExFVCcpIHtcclxuICAgICAgICBvcmRlclN0YXR1cyA9ICdDT05GSVJNRUQnOyAvLyBFbGVjdHJvbmljIHBheW1lbnRzIC0gYXNzdW1lIHBhaWQgaW1tZWRpYXRlbHlcclxuICAgICAgICBwYWlkQW1vdW50ID0gb3JkZXJBbW91bnQ7XHJcbiAgICAgIH0gZWxzZSBpZiAocGF5bWVudE1ldGhvZCA9PT0gJ0JBTksnKSB7XHJcbiAgICAgICAgb3JkZXJTdGF0dXMgPSAnUEFZTUVOVF9QRU5ESU5HJzsgLy8gQmFuayB0cmFuc2ZlciAtIGF3YWl0aW5nIHZlcmlmaWNhdGlvblxyXG4gICAgICAgIHBhaWRBbW91bnQgPSAwO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBvcmRlckNvZGUgPSBgQ0Mke0RhdGUubm93KCl9YDtcclxuICAgICAgXHJcbiAgICAgIC8vIENyZWF0ZSBGaXJlYmFzZSBvcmRlciBvYmplY3QgKHJlbW92aW5nIHVuZGVmaW5lZCB2YWx1ZXMpXHJcbiAgICAgIGNvbnN0IGZpcmVzdG9yZU9yZGVyOiBhbnkgPSB7XHJcbiAgICAgICAgb3JkZXJJZDogb3JkZXJDb2RlLFxyXG4gICAgICAgIHJlc3RhdXJhbnRJZDogcmVzdGF1cmFudCxcclxuICAgICAgICBvcmRlclN0YXR1cyxcclxuICAgICAgICBwYXltZW50TWV0aG9kLFxyXG4gICAgICAgIG9yZGVyQW1vdW50LFxyXG4gICAgICAgIHBhaWRBbW91bnQsXHJcbiAgICAgICAgZGVsaXZlcnlDaGFyZ2VzLFxyXG4gICAgICAgIHRpcHBpbmcsXHJcbiAgICAgICAgdGF4YXRpb25BbW91bnQsXHJcbiAgICAgICAgb3JkZXJEYXRlOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgaXNQaWNrZWRVcCxcclxuICAgICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxyXG4gICAgICAgIGl0ZW1zOiBvcmRlcklucHV0LFxyXG4gICAgICAgIC8vIFZlbmRvciBub3RpZmljYXRpb24gZmllbGRzIGZvciBNZW51VmVyc2UgaW50ZWdyYXRpb25cclxuICAgICAgICB2ZW5kb3JOb3RpZmllZDogZmFsc2UsXHJcbiAgICAgICAgb3JkZXJUeXBlOiAnZGVsaXZlcnknLFxyXG4gICAgICAgIHBsYXRmb3JtOiAnQ2hvcENob3AnXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBPbmx5IGFkZCBvcHRpb25hbCBmaWVsZHMgaWYgdGhleSBoYXZlIHZhbHVlc1xyXG4gICAgICBpZiAoYWRkcmVzcz8uZGVsaXZlcnlBZGRyZXNzKSB7XHJcbiAgICAgICAgZmlyZXN0b3JlT3JkZXIuZGVsaXZlcnlBZGRyZXNzID0gYWRkcmVzcy5kZWxpdmVyeUFkZHJlc3M7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGFkZHJlc3M/LmxhdGl0dWRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBmaXJlc3RvcmVPcmRlci5kZWxpdmVyeUxhdGl0dWRlID0gYWRkcmVzcy5sYXRpdHVkZTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoYWRkcmVzcz8ubG9uZ2l0dWRlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBmaXJlc3RvcmVPcmRlci5kZWxpdmVyeUxvbmdpdHVkZSA9IGFkZHJlc3MubG9uZ2l0dWRlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpbnN0cnVjdGlvbnMpIHtcclxuICAgICAgICBmaXJlc3RvcmVPcmRlci5pbnN0cnVjdGlvbnMgPSBpbnN0cnVjdGlvbnM7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIFNhdmUgdG8gRmlyZWJhc2Ugb3JkZXJzIGNvbGxlY3Rpb25cclxuICAgICAgY29uc3QgZG9jUmVmID0gYXdhaXQgYWRkRG9jKGNvbGxlY3Rpb24oZGIsICdvcmRlcnMnKSwgZmlyZXN0b3JlT3JkZXIpO1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIE9yZGVyICR7b3JkZXJDb2RlfSBzYXZlZCB0byBGaXJlYmFzZSB3aXRoIElEOmAsIGRvY1JlZi5pZCk7XHJcblxyXG4gICAgICAvLyBBTFNPIHNhdmUgdG8gdmVuZG9yLXNwZWNpZmljIGNvbGxlY3Rpb24gZm9yIE1lbnVWZXJzZSBub3RpZmljYXRpb25zXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5qAIFNUQVJUSU5HIHZlbmRvciBzYXZlIHByb2Nlc3MgZm9yIG9yZGVyICR7b3JkZXJDb2RlfS4uLmApO1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIC8vIER5bmFtaWMgcmVzdGF1cmFudC10by12ZW5kb3IgbWFwcGluZ1xyXG4gICAgICAgIC8vIEluIHByb2R1Y3Rpb24sIHRoaXMgd291bGQgY29tZSBmcm9tIGEgZGF0YWJhc2UgbG9va3VwXHJcbiAgICAgICAgLy8gRm9yIG5vdywgd2UnbGwgdHJ5IHRvIGZpbmQgdGhlIHZlbmRvciBVSUQgZHluYW1pY2FsbHlcclxuICAgICAgICBcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBMb29raW5nIHVwIHZlbmRvciBmb3IgcmVzdGF1cmFudCBJRDogJHtyZXN0YXVyYW50fWApO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE1ldGhvZCAxOiBUcnkgdG8gZmluZCB2ZW5kb3IgYnkgcXVlcnlpbmcgdGhlIGVhdGVyaWVzIGNvbGxlY3Rpb25cclxuICAgICAgICBsZXQgdmVuZG9yVUlEOiBzdHJpbmcgfCBudWxsID0gbnVsbDtcclxuICAgICAgICBcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgLy8gUXVlcnkgdGhlIGVhdGVyaWVzIGNvbGxlY3Rpb24gdG8gZmluZCB3aGljaCB2ZW5kb3Igb3ducyB0aGlzIHJlc3RhdXJhbnRcclxuICAgICAgICAgIGNvbnN0IGVhdGVyaWVzU25hcHNob3QgPSBhd2FpdCBnZXREb2NzKGNvbGxlY3Rpb24oZGIsICdlYXRlcmllcycpKTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgZm9yIChjb25zdCBkb2Mgb2YgZWF0ZXJpZXNTbmFwc2hvdC5kb2NzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGVhdGVyeURhdGEgPSBkb2MuZGF0YSgpO1xyXG4gICAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGVhdGVyeSBoYXMgdGhpcyByZXN0YXVyYW50IElEXHJcbiAgICAgICAgICAgIC8vIFRoaXMgYXNzdW1lcyB0aGUgZWF0ZXJ5IGRvY3VtZW50IGhhcyBhIHJlc3RhdXJhbnRJZHMgYXJyYXkgb3Igc2ltaWxhclxyXG4gICAgICAgICAgICBpZiAoZWF0ZXJ5RGF0YS5yZXN0YXVyYW50SWRzICYmIGVhdGVyeURhdGEucmVzdGF1cmFudElkcy5pbmNsdWRlcyhyZXN0YXVyYW50KSkge1xyXG4gICAgICAgICAgICAgIHZlbmRvclVJRCA9IGRvYy5pZDtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIHZlbmRvciAke3ZlbmRvclVJRH0gZm9yIHJlc3RhdXJhbnQgJHtyZXN0YXVyYW50fWApO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEFsdGVybmF0aXZlOiBjaGVjayBpZiByZXN0YXVyYW50IElEIG1hdGNoZXMgdGhlIGVhdGVyeSBJRFxyXG4gICAgICAgICAgICBpZiAoZWF0ZXJ5RGF0YS5pZCA9PT0gcmVzdGF1cmFudCB8fCBlYXRlcnlEYXRhLnJlc3RhdXJhbnRJZCA9PT0gcmVzdGF1cmFudCkge1xyXG4gICAgICAgICAgICAgIHZlbmRvclVJRCA9IGRvYy5pZDtcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIHZlbmRvciAke3ZlbmRvclVJRH0gZm9yIHJlc3RhdXJhbnQgJHtyZXN0YXVyYW50fSAoZGlyZWN0IG1hdGNoKWApO1xyXG4gICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBjYXRjaCAobG9va3VwRXJyb3IpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIENvdWxkIG5vdCBsb29rdXAgdmVuZG9yIGZyb20gZWF0ZXJpZXMgY29sbGVjdGlvbjonLCBsb29rdXBFcnJvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIE1ldGhvZCAyOiBJZiBubyBzcGVjaWZpYyBtYXBwaW5nIGZvdW5kLCBzYXZlIHRvIGFsbCBhY3RpdmUgdmVuZG9yc1xyXG4gICAgICAgIC8vIFRoaXMgZW5zdXJlcyBvcmRlcnMgZG9uJ3QgZ2V0IGxvc3Qgd2hpbGUgdGhlIG1hcHBpbmcgc3lzdGVtIGlzIGJlaW5nIHNldCB1cFxyXG4gICAgICAgIGNvbnN0IHZlbmRvclVJRHM6IHN0cmluZ1tdID0gW107XHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHZlbmRvclVJRCkge1xyXG4gICAgICAgICAgdmVuZG9yVUlEcy5wdXNoKHZlbmRvclVJRCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SEIE5vIHNwZWNpZmljIHZlbmRvciBmb3VuZCBmb3IgcmVzdGF1cmFudCAke3Jlc3RhdXJhbnR9LCB3aWxsIHNhdmUgdG8gYWxsIGFjdGl2ZSB2ZW5kb3JzYCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIEdldCBhbGwgdmVuZG9yIFVJRHMgZnJvbSBlYXRlcmllcyBjb2xsZWN0aW9uXHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBjb25zdCBhbGxFYXRlcmllc1NuYXBzaG90ID0gYXdhaXQgZ2V0RG9jcyhjb2xsZWN0aW9uKGRiLCAnZWF0ZXJpZXMnKSk7XHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoYWxsRWF0ZXJpZXNTbmFwc2hvdC5kb2NzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgICBjb25zdCBhbGxWZW5kb3JVSURzID0gYWxsRWF0ZXJpZXNTbmFwc2hvdC5kb2NzLm1hcChkb2MgPT4gZG9jLmlkKTtcclxuICAgICAgICAgICAgICB2ZW5kb3JVSURzLnB1c2goLi4uYWxsVmVuZG9yVUlEcyk7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk4sgRm91bmQgJHthbGxWZW5kb3JVSURzLmxlbmd0aH0gYWN0aXZlIHZlbmRvcnM6YCwgYWxsVmVuZG9yVUlEcyk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCfk60gTm8gZWF0ZXJpZXMgY29sbGVjdGlvbiBmb3VuZC4gQ3JlYXRpbmcgdmVuZG9yIGVudHJ5IGZvciBjdXJyZW50IGRlbW8gdXNlci5gKTtcclxuICAgICAgICAgICAgICAvLyBJZiBubyBlYXRlcmllcyBleGlzdCwgY3JlYXRlIG9uZSBmb3IgdGhlIGRlbW8gdmVuZG9yXHJcbiAgICAgICAgICAgICAgdmVuZG9yVUlEcy5wdXNoKCcwR0kzTW9qVm5MZnZ6U0VxTWMyNW9DekFtQ3oyJyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gY2F0Y2ggKGFsbFZlbmRvcnNFcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ+KaoO+4jyBDb3VsZCBub3QgZ2V0IGFsbCB2ZW5kb3JzLCB1c2luZyBmYWxsYmFjayBVSURzJyk7XHJcbiAgICAgICAgICAgIC8vIEZhbGxiYWNrIHRvIGtub3duIFVJRHMgaWYgdGhlIHF1ZXJ5IGZhaWxzXHJcbiAgICAgICAgICAgIHZlbmRvclVJRHMucHVzaCgnMEdJM01valZuTGZ2elNFcU1jMjVvQ3pBbUN6MicpOyAvLyBDdXJyZW50IGRlbW8gdmVuZG9yXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+OryBXaWxsIHNhdmUgb3JkZXIgdG8gJHt2ZW5kb3JVSURzLmxlbmd0aH0gdmVuZG9yKHMpOmAsIHZlbmRvclVJRHMpO1xyXG5cclxuICAgICAgICAvLyBTYXZlIG9yZGVyIHRvIGVhY2ggdmVuZG9yJ3MgY29sbGVjdGlvblxyXG4gICAgICAgIGZvciAoY29uc3QgY3VycmVudFZlbmRvclVJRCBvZiB2ZW5kb3JVSURzKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAvLyBGaXJzdCwgZW5zdXJlIHRoZSB2ZW5kb3IncyBlYXRlcnkgZG9jdW1lbnQgZXhpc3RzXHJcbiAgICAgICAgICAgIGNvbnN0IGVhdGVyeURvY1JlZiA9IGRvYyhkYiwgJ2VhdGVyaWVzJywgY3VycmVudFZlbmRvclVJRCk7XHJcbiAgICAgICAgICAgIGF3YWl0IHNldERvYyhlYXRlcnlEb2NSZWYsIHtcclxuICAgICAgICAgICAgICBpZDogY3VycmVudFZlbmRvclVJRCxcclxuICAgICAgICAgICAgICBuYW1lOiByZXN0YXVyYW50TmFtZSB8fCAnUmVzdGF1cmFudCcsIC8vIFVzZSBhY3R1YWwgcmVzdGF1cmFudCBuYW1lXHJcbiAgICAgICAgICAgICAgZW1haWw6ICd2ZW5kb3JAY2hvcGNob3AuY29tJyxcclxuICAgICAgICAgICAgICBjcmVhdGVkQXQ6IHNlcnZlclRpbWVzdGFtcCgpLFxyXG4gICAgICAgICAgICAgIHJlc3RhdXJhbnRJZHM6IFtyZXN0YXVyYW50XSAvLyBNYXAgdGhpcyB2ZW5kb3IgdG8gdGhpcyByZXN0YXVyYW50XHJcbiAgICAgICAgICAgIH0sIHsgbWVyZ2U6IHRydWUgfSk7IC8vIG1lcmdlOiB0cnVlIG1lYW5zIG9ubHkgdXBkYXRlIGlmIGRvY3VtZW50IGRvZXNuJ3QgZXhpc3RcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgRW5zdXJlZCBlYXRlcnkgZG9jdW1lbnQgZXhpc3RzIGZvciB2ZW5kb3I6ICR7Y3VycmVudFZlbmRvclVJRH1gKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IHZlbmRvck9yZGVyRGF0YSA9IHtcclxuICAgICAgICAgICAgICAvLyBVc2UgdGhlIGV4YWN0IHNhbWUgc3RydWN0dXJlIHRoYXQgTWVudVZlcnNlIGV4cGVjdHNcclxuICAgICAgICAgICAgICBpZDogZG9jUmVmLmlkLFxyXG4gICAgICAgICAgICAgIGVhdGVyeUlkOiBjdXJyZW50VmVuZG9yVUlELFxyXG4gICAgICAgICAgICAgIGN1c3RvbWVyOiB7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiBjdXN0b21lcj8ubmFtZSB8fCAnQ2hvcENob3AgQ3VzdG9tZXInLFxyXG4gICAgICAgICAgICAgICAgZW1haWw6IGN1c3RvbWVyPy5lbWFpbCB8fCAnY3VzdG9tZXJAY2hvcGNob3AuY29tJyxcclxuICAgICAgICAgICAgICAgIGFkZHJlc3M6IGFkZHJlc3M/LmRlbGl2ZXJ5QWRkcmVzcyB8fCBjdXN0b21lcj8uYWRkcmVzcyB8fCAnTm8gYWRkcmVzcyBwcm92aWRlZCdcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIGl0ZW1zOiBvcmRlcklucHV0Lm1hcCgoaXRlbSwgaW5kZXgpID0+ICh7XHJcbiAgICAgICAgICAgICAgICBpZDogYCR7ZG9jUmVmLmlkfS1pdGVtLSR7aW5kZXh9YCxcclxuICAgICAgICAgICAgICAgIG5hbWU6IGl0ZW0udGl0bGUsXHJcbiAgICAgICAgICAgICAgICBxdWFudGl0eTogaXRlbS5xdWFudGl0eSxcclxuICAgICAgICAgICAgICAgIHByaWNlOiBpdGVtLnByaWNlXHJcbiAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgIHRvdGFsQW1vdW50OiBvcmRlckFtb3VudCxcclxuICAgICAgICAgICAgICBzdGF0dXM6IG9yZGVyU3RhdHVzID09PSAnUEVORElORycgPyAnUGVuZGluZycgOiBcclxuICAgICAgICAgICAgICAgICAgICAgb3JkZXJTdGF0dXMgPT09ICdDT05GSVJNRUQnID8gJ0NvbmZpcm1lZCcgOiAnUGVuZGluZycsXHJcbiAgICAgICAgICAgICAgY3JlYXRlZEF0OiBmaXJlc3RvcmVPcmRlci5jcmVhdGVkQXQsXHJcbiAgICAgICAgICAgICAgLy8gQWRkaXRpb25hbCBDaG9wQ2hvcCBzcGVjaWZpYyBmaWVsZHNcclxuICAgICAgICAgICAgICBvcmRlcklkOiBvcmRlckNvZGUsXHJcbiAgICAgICAgICAgICAgcmVzdGF1cmFudElkOiByZXN0YXVyYW50LFxyXG4gICAgICAgICAgICAgIHBheW1lbnRNZXRob2QsXHJcbiAgICAgICAgICAgICAgcGxhdGZvcm06ICdDaG9wQ2hvcCdcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGNvbnN0IHZlbmRvclBhdGggPSBgZWF0ZXJpZXMvJHtjdXJyZW50VmVuZG9yVUlEfS9vcmRlcnNgO1xyXG4gICAgICAgICAgICBjb25zdCB2ZW5kb3JEb2NSZWYgPSBhd2FpdCBhZGREb2MoY29sbGVjdGlvbihkYiwgJ2VhdGVyaWVzJywgY3VycmVudFZlbmRvclVJRCwgJ29yZGVycycpLCB2ZW5kb3JPcmRlckRhdGEpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBPcmRlciAke29yZGVyQ29kZX0gc2F2ZWQgdG8gdmVuZG9yIHBhdGg6ICR7dmVuZG9yUGF0aH0gd2l0aCBJRDogJHt2ZW5kb3JEb2NSZWYuaWR9YCk7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OKIE9yZGVyIGRhdGEgc2F2ZWQ6YCwgdmVuZG9yT3JkZXJEYXRhKTtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYPCfjq8gVkVSSUZJQ0FUSU9OOiBPcmRlciBzaG91bGQgYmUgdmlzaWJsZSBhdCBGaXJlYmFzZSBwYXRoOiBlYXRlcmllcy8ke2N1cnJlbnRWZW5kb3JVSUR9L29yZGVycy8ke3ZlbmRvckRvY1JlZi5pZH1gKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIPCflIQgU1lOQyBUTyBDVVNUT01FUiBPUkRFUlM6IFNhdmUgb3JkZXIgdG8gY3VzdG9tZXItYWNjZXNzaWJsZSBjb2xsZWN0aW9uXHJcbiAgICAgICAgICAgIC8vIFRlbXBvcmFyaWx5IGRpc2FibGVkIHRvIGZpeCBidWlsZCBpc3N1ZVxyXG4gICAgICAgICAgICAvKlxyXG4gICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGN1c3RvbWVyT3JkZXJJZCA9IGF3YWl0IE9yZGVyU3luY1NlcnZpY2Uuc2F2ZUN1c3RvbWVyT3JkZXIoe1xyXG4gICAgICAgICAgICAgICAgb3JkZXJJZDogb3JkZXJDb2RlLFxyXG4gICAgICAgICAgICAgICAgY3VzdG9tZXJJZDogY3VzdG9tZXI/LmVtYWlsIHx8IGBjdXN0b21lci0ke0RhdGUubm93KCl9YCwgLy8gVXNlIGVtYWlsIGFzIGN1c3RvbWVyIElEXHJcbiAgICAgICAgICAgICAgICB2ZW5kb3JJZDogY3VycmVudFZlbmRvclVJRCxcclxuICAgICAgICAgICAgICAgIHJlc3RhdXJhbnRJZDogcmVzdGF1cmFudCxcclxuICAgICAgICAgICAgICAgIHJlc3RhdXJhbnROYW1lOiByZXN0YXVyYW50TmFtZSB8fCAnUmVzdGF1cmFudCcsIC8vIFVzZSBhY3R1YWwgcmVzdGF1cmFudCBuYW1lXHJcbiAgICAgICAgICAgICAgICBjdXN0b21lcjoge1xyXG4gICAgICAgICAgICAgICAgICBuYW1lOiBjdXN0b21lcj8ubmFtZSB8fCAnQ2hvcENob3AgQ3VzdG9tZXInLFxyXG4gICAgICAgICAgICAgICAgICBlbWFpbDogY3VzdG9tZXI/LmVtYWlsIHx8ICdjdXN0b21lckBjaG9wY2hvcC5jb20nLFxyXG4gICAgICAgICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzPy5kZWxpdmVyeUFkZHJlc3MgfHwgY3VzdG9tZXI/LmFkZHJlc3MgfHwgJ05vIGFkZHJlc3MgcHJvdmlkZWQnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgaXRlbXM6IG9yZGVySW5wdXQubWFwKChpdGVtLCBpbmRleCkgPT4gKHtcclxuICAgICAgICAgICAgICAgICAgaWQ6IGAke29yZGVyQ29kZX0taXRlbS0ke2luZGV4fWAsXHJcbiAgICAgICAgICAgICAgICAgIG5hbWU6IGl0ZW0udGl0bGUsXHJcbiAgICAgICAgICAgICAgICAgIHF1YW50aXR5OiBpdGVtLnF1YW50aXR5LFxyXG4gICAgICAgICAgICAgICAgICBwcmljZTogaXRlbS5wcmljZVxyXG4gICAgICAgICAgICAgICAgfSkpLFxyXG4gICAgICAgICAgICAgICAgdG90YWxBbW91bnQ6IG9yZGVyQW1vdW50LFxyXG4gICAgICAgICAgICAgICAgc3RhdHVzOiBvcmRlclN0YXR1cyA9PT0gJ1BFTkRJTkcnID8gJ1BlbmRpbmcnIDogXHJcbiAgICAgICAgICAgICAgICAgICAgICAgb3JkZXJTdGF0dXMgPT09ICdDT05GSVJNRUQnID8gJ0NvbmZpcm1lZCcgOiAnUGVuZGluZycsXHJcbiAgICAgICAgICAgICAgICBwYXltZW50TWV0aG9kOiBwYXltZW50TWV0aG9kXHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgaWYgKGN1c3RvbWVyT3JkZXJJZCkge1xyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYOKchSBDdXN0b21lciBvcmRlciBzeW5jZWQ6IGN1c3RvbWVyLW9yZGVycy8ke2N1c3RvbWVyT3JkZXJJZH1gKTtcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKHN5bmNFcnJvcikge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIEZhaWxlZCB0byBzeW5jIGN1c3RvbWVyIG9yZGVyOicsIHN5bmNFcnJvcik7XHJcbiAgICAgICAgICAgICAgLy8gRG9uJ3QgZmFpbCB0aGUgbWFpbiBvcmRlciAtIHRoaXMgaXMgc3VwcGxlbWVudGFyeVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgfSBjYXRjaCAocGF0aEVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYOKdjCBGYWlsZWQgdG8gc2F2ZSB0byB2ZW5kb3IgVUlEICR7Y3VycmVudFZlbmRvclVJRH06YCwgcGF0aEVycm9yKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElNUE9SVEFOVDogTGV0J3MgYWxzbyB0cnkgdG8gc2F2ZSB0byBhIHByZWRpY3RhYmxlIHBhdGggZm9yIHRlc3RpbmdcclxuICAgICAgICAvLyBUaGlzIHdpbGwgaGVscCB1cyBkZWJ1ZyB3aGF0J3MgaGFwcGVuaW5nXHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIGNvbnN0IGRlYnVnT3JkZXJEYXRhID0ge1xyXG4gICAgICAgICAgICBpZDogZG9jUmVmLmlkLFxyXG4gICAgICAgICAgICBlYXRlcnlJZDogJ0RFQlVHX1ZFTkRPUicsXHJcbiAgICAgICAgICAgIGN1c3RvbWVyOiB7IG5hbWU6ICdEZWJ1ZyBDdXN0b21lcicsIGVtYWlsOiAnZGVidWdAdGVzdC5jb20nLCBhZGRyZXNzOiAnRGVidWcgQWRkcmVzcycgfSxcclxuICAgICAgICAgICAgaXRlbXM6IFt7IGlkOiAnZGVidWctaXRlbScsIG5hbWU6ICdEZWJ1ZyBJdGVtJywgcXVhbnRpdHk6IDEsIHByaWNlOiAxMC45OSB9XSxcclxuICAgICAgICAgICAgdG90YWxBbW91bnQ6IDEwLjk5LFxyXG4gICAgICAgICAgICBzdGF0dXM6ICdQZW5kaW5nJyxcclxuICAgICAgICAgICAgY3JlYXRlZEF0OiBmaXJlc3RvcmVPcmRlci5jcmVhdGVkQXQsXHJcbiAgICAgICAgICAgIGRlYnVnSW5mbzoge1xyXG4gICAgICAgICAgICAgIG9yaWdpbmFsUmVzdGF1cmFudElkOiByZXN0YXVyYW50LFxyXG4gICAgICAgICAgICAgIG9yZGVyQ29kZTogb3JkZXJDb2RlLFxyXG4gICAgICAgICAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxyXG4gICAgICAgICAgICAgIHNvdXJjZTogJ0Nob3BDaG9wIERlYnVnIFNhdmUnXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH07XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGF3YWl0IGFkZERvYyhjb2xsZWN0aW9uKGRiLCAnZWF0ZXJpZXMnLCAnREVCVUdfVkVORE9SJywgJ29yZGVycycpLCBkZWJ1Z09yZGVyRGF0YSk7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg8J+QmyBERUJVRzogT3JkZXIgc2F2ZWQgdG8gZWF0ZXJpZXMvREVCVUdfVkVORE9SL29yZGVycyBmb3IgdGVzdGluZ2ApO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgfSBjYXRjaCAoZGVidWdFcnJvcikge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKCdEZWJ1ZyBzYXZlIGZhaWxlZDonLCBkZWJ1Z0Vycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgIH0gY2F0Y2ggKHZlbmRvckVycm9yKSB7XHJcbiAgICAgICAgY29uc29sZS5lcnJvcign4pqg77iPIEZhaWxlZCB0byBzYXZlIHRvIHZlbmRvciBjb2xsZWN0aW9uczonLCB2ZW5kb3JFcnJvcik7XHJcbiAgICAgICAgLy8gRG9uJ3QgdGhyb3cgLSBnbG9iYWwgb3JkZXIgd2FzIHNhdmVkIHN1Y2Nlc3NmdWxseVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIG9yZGVySWQ6IG9yZGVyQ29kZSxcclxuICAgICAgICBvcmRlclN0YXR1cyxcclxuICAgICAgICB0b3RhbDogb3JkZXJBbW91bnQsXHJcbiAgICAgICAgZmlyZWJhc2VJZDogZG9jUmVmLmlkXHJcbiAgICAgIH07XHJcbiAgICAgIFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZpcmViYXNlIG9yZGVyIGNyZWF0aW9uIGZhaWxlZDonLCBlcnJvcik7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBsYWNlIG9yZGVyOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBzdGF0aWMgYXN5bmMgdXBkYXRlT3JkZXJTdGF0dXMoZmlyZWJhc2VJZDogc3RyaW5nLCBzdGF0dXM6IHN0cmluZywgcGFpZEFtb3VudD86IG51bWJlcikge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgeyB1cGRhdGVEb2MsIGRvYyB9ID0gYXdhaXQgaW1wb3J0KCdmaXJlYmFzZS9maXJlc3RvcmUnKTtcclxuICAgICAgY29uc3Qgb3JkZXJSZWYgPSBkb2MoZGIsICdvcmRlcnMnLCBmaXJlYmFzZUlkKTtcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHVwZGF0ZURhdGE6IGFueSA9IHtcclxuICAgICAgICBvcmRlclN0YXR1czogc3RhdHVzLFxyXG4gICAgICAgIHVwZGF0ZWRBdDogc2VydmVyVGltZXN0YW1wKClcclxuICAgICAgfTtcclxuICAgICAgXHJcbiAgICAgIGlmIChwYWlkQW1vdW50ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICB1cGRhdGVEYXRhLnBhaWRBbW91bnQgPSBwYWlkQW1vdW50O1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBhd2FpdCB1cGRhdGVEb2Mob3JkZXJSZWYsIHVwZGF0ZURhdGEpO1xyXG4gICAgICBjb25zb2xlLmxvZyhg4pyFIE9yZGVyICR7ZmlyZWJhc2VJZH0gc3RhdHVzIHVwZGF0ZWQgdG8gJHtzdGF0dXN9YCk7XHJcbiAgICAgIFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEZpcmViYXNlIG9yZGVyIHVwZGF0ZSBmYWlsZWQ6JywgZXJyb3IpO1xyXG4gICAgICB0aHJvdyBlcnJvcjtcclxuICAgIH1cclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IE9yZGVyU2VydmljZTsiXSwibmFtZXMiOlsiZ2V0RmlyZXN0b3JlIiwiY29sbGVjdGlvbiIsImFkZERvYyIsInNlcnZlclRpbWVzdGFtcCIsImdldERvY3MiLCJkb2MiLCJzZXREb2MiLCJnZXRGaXJlYmFzZUFwcCIsImRiIiwiT3JkZXJTZXJ2aWNlIiwicGxhY2VPcmRlciIsInJlc3RhdXJhbnQiLCJyZXN0YXVyYW50TmFtZSIsIm9yZGVySW5wdXQiLCJwYXltZW50TWV0aG9kIiwiYWRkcmVzcyIsImN1c3RvbWVyIiwiZGVsaXZlcnlDaGFyZ2VzIiwidGlwcGluZyIsInRheGF0aW9uQW1vdW50IiwiaW5zdHJ1Y3Rpb25zIiwiaXNQaWNrZWRVcCIsInN1YnRvdGFsIiwicmVkdWNlIiwic3VtIiwiaXRlbSIsInByaWNlIiwicXVhbnRpdHkiLCJvcmRlckFtb3VudCIsIm9yZGVyU3RhdHVzIiwicGFpZEFtb3VudCIsIm9yZGVyQ29kZSIsIkRhdGUiLCJub3ciLCJmaXJlc3RvcmVPcmRlciIsIm9yZGVySWQiLCJyZXN0YXVyYW50SWQiLCJvcmRlckRhdGUiLCJ0b0lTT1N0cmluZyIsImNyZWF0ZWRBdCIsIml0ZW1zIiwidmVuZG9yTm90aWZpZWQiLCJvcmRlclR5cGUiLCJwbGF0Zm9ybSIsImRlbGl2ZXJ5QWRkcmVzcyIsImxhdGl0dWRlIiwidW5kZWZpbmVkIiwiZGVsaXZlcnlMYXRpdHVkZSIsImxvbmdpdHVkZSIsImRlbGl2ZXJ5TG9uZ2l0dWRlIiwiZG9jUmVmIiwiY29uc29sZSIsImxvZyIsImlkIiwidmVuZG9yVUlEIiwiZWF0ZXJpZXNTbmFwc2hvdCIsImRvY3MiLCJlYXRlcnlEYXRhIiwiZGF0YSIsInJlc3RhdXJhbnRJZHMiLCJpbmNsdWRlcyIsImxvb2t1cEVycm9yIiwid2FybiIsInZlbmRvclVJRHMiLCJwdXNoIiwiYWxsRWF0ZXJpZXNTbmFwc2hvdCIsImxlbmd0aCIsImFsbFZlbmRvclVJRHMiLCJtYXAiLCJhbGxWZW5kb3JzRXJyb3IiLCJjdXJyZW50VmVuZG9yVUlEIiwiZWF0ZXJ5RG9jUmVmIiwibmFtZSIsImVtYWlsIiwibWVyZ2UiLCJ2ZW5kb3JPcmRlckRhdGEiLCJlYXRlcnlJZCIsImluZGV4IiwidGl0bGUiLCJ0b3RhbEFtb3VudCIsInN0YXR1cyIsInZlbmRvclBhdGgiLCJ2ZW5kb3JEb2NSZWYiLCJwYXRoRXJyb3IiLCJlcnJvciIsImRlYnVnT3JkZXJEYXRhIiwiZGVidWdJbmZvIiwib3JpZ2luYWxSZXN0YXVyYW50SWQiLCJ0aW1lc3RhbXAiLCJzb3VyY2UiLCJkZWJ1Z0Vycm9yIiwidmVuZG9yRXJyb3IiLCJ0b3RhbCIsImZpcmViYXNlSWQiLCJFcnJvciIsIm1lc3NhZ2UiLCJ1cGRhdGVPcmRlclN0YXR1cyIsInVwZGF0ZURvYyIsIm9yZGVyUmVmIiwidXBkYXRlRGF0YSIsInVwZGF0ZWRBdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./lib/firebase/orders.ts\n"));

/***/ })

});